<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Metro</name>
    </assembly>
    <members>
        <member name="T:Metro.Win32Error">
            <summary>
            	Allows formatting of win 32 errors
            </summary>
        </member>
        <member name="M:Metro.Win32Error.GetErrorMessage(System.Int32)">
            <summary>
            	Formats a win32 error code to a string description.
            </summary>
            <param name="errorCode">
            	The error code.
            </param>
            <returns>
            	The error code description
            </returns>
        </member>
        <member name="T:Metro.Filtering.IpV4Filter">
            <summary>
            	A class for filtering out IP packets by the source and destination address.
            </summary>
        </member>
        <member name="F:Metro.Filtering.IpV4Filter.m_sourceAddressFilter">
            <summary>
            	The array of source address filters. A packet must pass at least one of
            	these tests to mae it through.
            </summary>
        </member>
        <member name="F:Metro.Filtering.IpV4Filter.m_destAddressFilter">
            <summary>
            	The array of destination address filters. A packet must pass at least one of
            	these tests to mae it through.
            </summary>
        </member>
        <member name="F:Metro.Filtering.IpV4Filter.m_sourceAddressFilterIndexer">
            <summary>
            	The indexer class for the source address, allowing an indexed property.
            </summary>
        </member>
        <member name="F:Metro.Filtering.IpV4Filter.m_destAddressFilterIndexer">
            <summary>
            	The indexer class for the source address, allowing an indexed property.
            </summary>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.#ctor">
            <summary>
            	Create a new IpV4Filter class.
            </summary>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.AddSourceAddressFilter(System.String)">
             <summary>
            		Add a new source address filter. To be let through, the address
            		must match at least one of the filters.
             </summary>
             <param name="filter">
            		A string containing the pattern that the ip address must match
            		to be passed through. The filter must be in the same general form
            		as an ip address, in that it has 4 parts, seperated by periods.
            		Each part can be either a number such as 255, 128, 1; a range of
            		numbers of the form [min-max] such as [1-10], [128-255], [2-5]; or
            		a combination of numbers and wild cards (?) such as 1?, ?10, 20?, ??3.
            	</param>
             <example>
            		<code>
            			// match ip's such as 192.168.1.1, 192.168.6.100, 193.168.10.0 etc
            			string filter = "192.168.[1-10].?
            
            			int index = AddSourceAddressFilter (filter);
            		</code>
            	</example>
             <returns>
            		The index in the source address filters array.
            	</returns>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.AddDestinationAddressFilter(System.String)">
             <summary>
            		Add a new destination address filter. To be let through, the address
            		must match at least one of the filters.
             </summary>
             <param name="filter">
            		A string containing the pattern that the ip address must match
            		to be passed through. The filter must be in the same general form
            		as an ip address, in that it has 4 parts, seperated by periods.
            		Each part can be either a number such as 255, 128, 1; a range of
            		numbers of the form [min-max] such as [1-10], [128-255], [2-5]; or
            		a combination of numbers and wild cards (?) such as 1?, ?10, 20?, ??3.
            	</param>
             <example>
            		<code>
            			// match ip's such as 192.168.1.1, 192.168.6.100, 193.168.10.0 etc
            			string filter = "192.168.[1-10].?
            
            			int index = AddDestinationAddressFilter (filter);
            		</code>
            	</example>
             <returns>
            		The index in the destination address filters array.	
            	</returns>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.HandleNewPacket(Metro.NetworkLayer.IpV4.IpV4Packet)">
            <summary>
            	Whenever a new IP packet arrives it should be passed to this method.
            	If the packet is to be filtered out it will be ignored otherwise the
            	IpV4PacketArrived will be raised with the packet
            </summary>
            <param name="packet">
            	The packet which has arrived.
            </param>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.IsMatch(System.String,System.String)">
            <summary>
            	Check to see if an IP matches a pattern.
            </summary>
            <param name="address">
            	The IP address to check.
            </param>
            <param name="filter">
            	A string containing the pattern that the ip address must match
            	to be passed through. The filter must be in the same general form
            	as an ip address, in that it has 4 parts, seperated by periods.
            	Each part can be either a number such as 255, 128, 1; a range of
            	numbers of the form [min-max] such as [1-10], [128-255], [2-5]; or
            	a combination of numbers and wild cards (?) such as 1?, ?10, 20?, ??3.
            </param>
            <returns>
            	true, if they matched, false otherwise.
            </returns>
            <exception cref="T:System.ArgumentException">
            	ArgumentException is thrown if the IP address is invalid or if
            	the filter is invalid.
            </exception>
        </member>
        <member name="E:Metro.Filtering.IpV4Filter.IpV4PacketArrived">
            <summary>
            	The handler for when a new packet has arrived and has made it through
            	the filters.
            </summary>
        </member>
        <member name="P:Metro.Filtering.IpV4Filter.SourceAddressFilter">
            <summary>
            	The array of source address filters. A packet must pass at least one of these
            	to proceed.
            </summary>
        </member>
        <member name="P:Metro.Filtering.IpV4Filter.DestinationAddressFilter">
            <summary>
            	The array of source address filters. A packet must pass at least one of these
            	to proceed.
            </summary>
        </member>
        <member name="T:Metro.Filtering.IpV4Filter.SourceAddressFilterIndexer">
            <summary>
            	This class is used to provide an indexed property for the source address.
            </summary>
        </member>
        <member name="F:Metro.Filtering.IpV4Filter.SourceAddressFilterIndexer.owner">
            <summary>
            	The owner of the indexer.
            </summary>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.SourceAddressFilterIndexer.#ctor(Metro.Filtering.IpV4Filter)">
            <summary>
            	Create a new SourceAddressFilterIndexer class.
            </summary>
            <param name="owner">
            	The owner of the class.
            </param>
        </member>
        <member name="P:Metro.Filtering.IpV4Filter.SourceAddressFilterIndexer.Item(System.Int32)">
            <summary>
            	The indexer itself returns a single filter.
            </summary>
        </member>
        <member name="P:Metro.Filtering.IpV4Filter.SourceAddressFilterIndexer.Length">
            <summary>
            	The length of the array.
            </summary>
        </member>
        <member name="T:Metro.Filtering.IpV4Filter.DestinationAddressFilterIndexer">
            <summary>
            	This class is used to provide an indexed property for the destination address.
            </summary>
        </member>
        <member name="F:Metro.Filtering.IpV4Filter.DestinationAddressFilterIndexer.owner">
            <summary>
            	The owner of this class.
            </summary>
        </member>
        <member name="M:Metro.Filtering.IpV4Filter.DestinationAddressFilterIndexer.#ctor(Metro.Filtering.IpV4Filter)">
            <summary>
            	Create a new DestinationAddressFilterIndexer.
            </summary>
            <param name="owner">
            	The owner of the class.
            </param>
        </member>
        <member name="P:Metro.Filtering.IpV4Filter.DestinationAddressFilterIndexer.Item(System.Int32)">
            <summary>
            	The indexer returning individual elements in the array.
            </summary>
        </member>
        <member name="P:Metro.Filtering.IpV4Filter.DestinationAddressFilterIndexer.Length">
            <summary>
            	The length of the array.
            </summary>
        </member>
        <member name="T:Metro.Filtering.TcpFilter">
            <summary>
            	A class for filtering out TCP packets by the source and destination ports.
            </summary>
        </member>
        <member name="F:Metro.Filtering.TcpFilter.m_sourcePortFilter">
            <summary>
            	The array of source port filters. The packet must pass at least one of these
            	to proceed.
            </summary>
        </member>
        <member name="F:Metro.Filtering.TcpFilter.m_destPortFilter">
            <summary>
            	The array of destination port filters. The packet must pass at least one of these
            	to proceed.
            </summary>
        </member>
        <member name="F:Metro.Filtering.TcpFilter.m_sourcePortFilterIndexer">
            <summary>
            	The indexer class allowing access to the source portfilters.
            </summary>
        </member>
        <member name="F:Metro.Filtering.TcpFilter.m_destPortFilterIndexer">
            <summary>
            	The indexer class allowing access to the source portfilters.
            </summary>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.#ctor">
            <summary>
            	Create a new TcpFilter class.
            </summary>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.AddSourcePortFilter(System.String)">
             <summary>
            		Add a new source port filter. To be let through, the port
            		must match at least one of the filters.
             </summary>
             <param name="filter">
            		A string containing the pattern that the port must match
            		to be passed through. The filter can be either a number such as 6667, 80, 23; 
            		a range of numbers of the form [min-max] such as [1-1000], [1000-65535], [23-100]; 
            		or a combination of numbers and wild cards (?) such as ?10?, 666?, 2?, ??3.
            	</param>
             <example>
            		<code>
            			// match ports such as 6667, 6668, 6669 etc
            			string filter = "[6660-6669]"
            
            			int index = AddSourcePortFilter (filter);
            		</code>
            	</example>
             <returns>
            		The index in the source port filters array.
            	</returns>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.AddDestinationPortFilter(System.String)">
             <summary>
            		Add a new destination prt filter. To be let through, the port
            		must match at least one of the filters.
             </summary>
             <param name="filter">
            		A string containing the pattern that the port must match
            		to be passed through. The filter can be either a number such as 6667, 80, 23; 
            		a range of numbers of the form [min-max] such as [1-1000], [1000-65535], [23-100]; 
            		or a combination of numbers and wild cards (?) such as ?10?, 666?, 2?, ??3.
            	</param>
             <example>
            		<code>
            			// match ports such as 6667, 6668, 6669 etc
            			string filter = "[6660-6669]"
            
            			int index = AddSourcePortFilter (filter);
            		</code>
            	</example>
             <returns>
            		The index in the destination port filters array.	
            	</returns>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.HandleNewPacket(Metro.TransportLayer.Tcp.TcpPacket)">
            <summary>
            	Whenever a new TCP packet arrives it should be passed to this method.
            	If the packet is to be filtered out it will be ignored otherwise the
            	TcpPacketArrived will be raised with the packet
            </summary>
            <param name="packet">
            	The packet which has arrived.
            </param>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.IsMatch(System.UInt16,System.String)">
            <summary>
            	Check to see if an TCP matches a pattern.
            </summary>
            <param name="port">
            	The TCP address to check.
            </param>
            <param name="filter">
            	A string containing the pattern that the port must match
            	to be passed through. The filter can be either a number such as 6667, 80, 23; 
            	a range of numbers of the form [min-max] such as [1-1000], [1000-65535], [23-100]; 
            	or a combination of numbers and wild cards (?) such as ?10?, 666?, 2?, ??3.
            </param>
            <returns>
            	true, if they matched, false otherwise.
            </returns>
        </member>
        <member name="E:Metro.Filtering.TcpFilter.TcpPacketArrived">
            <summary>
            	The handler for when a new packet has arrived and has made it through
            	the filters.
            </summary>
        </member>
        <member name="P:Metro.Filtering.TcpFilter.SourcePortFilter">
            <summary>
            	The array of source port filters. The packet must pass at least one of these
            	to proceed.
            </summary>
        </member>
        <member name="P:Metro.Filtering.TcpFilter.DestinationPortFilter">
            <summary>
            	The array of destination port filters. The packet must pass at least one of these
            	to proceed.
            </summary>
        </member>
        <member name="T:Metro.Filtering.TcpFilter.TdpSourcePortFilterIndexer">
            <summary>
            	This class is used to provide an indexed property for the source port.
            </summary>
        </member>
        <member name="F:Metro.Filtering.TcpFilter.TdpSourcePortFilterIndexer.owner">
            <summary>
            	The owner of this indexer class.
            </summary>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.TdpSourcePortFilterIndexer.#ctor(Metro.Filtering.TcpFilter)">
            <summary>
            	Create a new TdpSourcePortFilterIndexer class.
            </summary>
            <param name="owner">
            	The owner.
            </param>
        </member>
        <member name="P:Metro.Filtering.TcpFilter.TdpSourcePortFilterIndexer.Item(System.Int32)">
            <summary>
            	The indexer.
            </summary>
        </member>
        <member name="P:Metro.Filtering.TcpFilter.TdpSourcePortFilterIndexer.Length">
            <summary>
            	The length of the array.
            </summary>
        </member>
        <member name="T:Metro.Filtering.TcpFilter.DestinationPortFilterIndexer">
            <summary>
            	This class is used to provide an indexed property for the destination port.
            </summary>
        </member>
        <member name="F:Metro.Filtering.TcpFilter.DestinationPortFilterIndexer.owner">
            <summary>
            	The owner of this class
            </summary>
        </member>
        <member name="M:Metro.Filtering.TcpFilter.DestinationPortFilterIndexer.#ctor(Metro.Filtering.TcpFilter)">
            <summary>
            	Create a new DestinationPortFilterIndexer class.
            </summary>
            <param name="owner">
            	The owner.
            </param>
        </member>
        <member name="P:Metro.Filtering.TcpFilter.DestinationPortFilterIndexer.Item(System.Int32)">
            <summary>
            The indexer.
            </summary>
        </member>
        <member name="P:Metro.Filtering.TcpFilter.DestinationPortFilterIndexer.Length">
            <summary>
            	The length of the array.
            </summary>
        </member>
        <member name="T:Metro.Filtering.UdpFilter">
            <summary>
            	A class for filtering out UDP packets by the source and destination ports.
            </summary>
        </member>
        <member name="F:Metro.Filtering.UdpFilter.m_sourcePortFilter">
            <summary>
            	The source port filter array. The packet must pass at least one of these to
            	proceed.
            </summary>
        </member>
        <member name="F:Metro.Filtering.UdpFilter.m_destPortFilter">
            <summary>
            	The destination port filter array. The packet must pass at least one of these to
            	proceed.
            </summary>
        </member>
        <member name="F:Metro.Filtering.UdpFilter.m_sourcePortFilterIndexer">
            <summary>
            	The source port filter array indexer.
            </summary>
        </member>
        <member name="F:Metro.Filtering.UdpFilter.m_destPortFilterIndexer">
            <summary>
            	The destination port filter array indexer.
            </summary>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.#ctor">
            <summary>
            	Create a new UdpFilter class.
            </summary>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.AddSourcePortFilter(System.String)">
             <summary>
            		Add a new source port filter. To be let through, the port
            		must match at least one of the filters.
             </summary>
             <param name="filter">
            		A string containing the pattern that the port must match
            		to be passed through. The filter can be either a number such as 6667, 80, 23; 
            		a range of numbers of the form [min-max] such as [1-1000], [1000-65535], [23-100]; 
            		or a combination of numbers and wild cards (?) such as ?10?, 666?, 2?, ??3.
            	</param>
             <example>
            		<code>
            			// match ports such as 6667, 6668, 6669 etc
            			string filter = "[6660-6669]"
            
            			int index = AddSourcePortFilter (filter);
            		</code>
            	</example>
             <returns>
            		The index in the source port filters array.
            	</returns>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.AddDestinationPortFilter(System.String)">
             <summary>
            		Add a new destination prt filter. To be let through, the port
            		must match at least one of the filters.
             </summary>
             <param name="filter">
            		A string containing the pattern that the port must match
            		to be passed through. The filter can be either a number such as 6667, 80, 23; 
            		a range of numbers of the form [min-max] such as [1-1000], [1000-65535], [23-100]; 
            		or a combination of numbers and wild cards (?) such as ?10?, 666?, 2?, ??3.
            	</param>
             <example>
            		<code>
            			// match ports such as 6667, 6668, 6669 etc
            			string filter = "[6660-6669]"
            
            			int index = AddSourcePortFilter (filter);
            		</code>
            	</example>
             <returns>
            		The index in the destination port filters array.	
            	</returns>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.HandleNewPacket(Metro.TransportLayer.Udp.UdpPacket)">
            <summary>
            	Whenever a new UDP packet arrives it should be passed to this method.
            	If the packet is to be filtered out it will be ignored otherwise the
            	UdpPacketArrived will be raised with the packet
            </summary>
            <param name="packet">
            	The packet which has arrived.
            </param>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.IsMatch(System.UInt16,System.String)">
            <summary>
            	Check to see if an UDP matches a pattern.
            </summary>
            <param name="port">
            	The UDP address to check.
            </param>
            <param name="filter">
            	A string containing the pattern that the port must match
            	to be passed through. The filter can be either a number such as 6667, 80, 23; 
            	a range of numbers of the form [min-max] such as [1-1000], [1000-65535], [23-100]; 
            	or a combination of numbers and wild cards (?) such as ?10?, 666?, 2?, ??3.
            </param>
            <returns>
            	true, if they matched, false otherwise.
            </returns>
        </member>
        <member name="E:Metro.Filtering.UdpFilter.UdpPacketArrived">
            <summary>
            	The handler for when a new packet has arrived and has made it through
            	the filters.
            </summary>
        </member>
        <member name="P:Metro.Filtering.UdpFilter.SourcePortFilter">
            <summary>
            	The source port filter array. The packet must pass at least one of these to
            	proceed.
            </summary>
        </member>
        <member name="P:Metro.Filtering.UdpFilter.DestinationPortFilter">
            <summary>
            	The source destination filter array. The packet must pass at least one of these to
            	proceed. 
            </summary>
        </member>
        <member name="T:Metro.Filtering.UdpFilter.UdpSourcePortFilterIndexer">
            <summary>
            	This class is used to provide an indexed property for the source port.
            </summary>
        </member>
        <member name="F:Metro.Filtering.UdpFilter.UdpSourcePortFilterIndexer.owner">
            <summary>
            	The owner class.
            </summary>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.UdpSourcePortFilterIndexer.#ctor(Metro.Filtering.UdpFilter)">
            <summary>
            	Create a new UdpSourcePortFilterIndexer class.
            </summary>
            <param name="owner">
            	The owner.
            </param>
        </member>
        <member name="P:Metro.Filtering.UdpFilter.UdpSourcePortFilterIndexer.Item(System.Int32)">
            <summary>
            	The indexer.
            </summary>
        </member>
        <member name="P:Metro.Filtering.UdpFilter.UdpSourcePortFilterIndexer.Length">
            <summary>
            	The length of the array.
            </summary>
        </member>
        <member name="T:Metro.Filtering.UdpFilter.DestinationPortFilterIndexer">
            <summary>
            	This class is used to provide an indexed property for the destination port.
            </summary>
        </member>
        <member name="F:Metro.Filtering.UdpFilter.DestinationPortFilterIndexer.owner">
            <summary>
            	The owner.
            </summary>
        </member>
        <member name="M:Metro.Filtering.UdpFilter.DestinationPortFilterIndexer.#ctor(Metro.Filtering.UdpFilter)">
            <summary>
            	Create a new DestinationPortFilterIndexer class.
            </summary>
            <param name="owner">
            	The owner class.
            </param>
        </member>
        <member name="P:Metro.Filtering.UdpFilter.DestinationPortFilterIndexer.Item(System.Int32)">
            <summary>
            	The indexer.
            </summary>
        </member>
        <member name="P:Metro.Filtering.UdpFilter.DestinationPortFilterIndexer.Length">
            <summary>
            	The length of the array.
            </summary>
        </member>
        <member name="T:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol">
            <summary>
            	Network layer protocols as they are represented in the ethernet
            	header.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol.ARP">
            <summary>
            	Address Resolution Protocol (for IP and CHAOS).
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol.AARP">
            <summary>
            	AppleTalk Address Resolution Protocol.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol.EtherTalk">
            <summary>
            	AppleTalk over Ethernet.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol.IP">
            <summary>
            	Internet Protocol version 4.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol.IPv6">
            <summary>
            	Internet Protocol version 6.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.NetworkLayerProtocol.RARP">
            <summary>
            	Reverse Address Resolution Protocol
            </summary>
        </member>
        <member name="T:Metro.LinkLayer.Ethernet802_3.Ethernet802_3">
            <summary>
            	The following is a class for using the Ethernet Frame Format described in 
            	the IEEE 802.3 Specification. The 802.3 Specification defines a 14 byte 
            	Data Link Header followed by a Logical Link Control Header that is defined 
            	by the 802.2 Specification.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.m_sourceMACAddress">
            <summary>
            	The source MAC address. The Source address specifies from which 
            	adapter the message originated.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.m_destinationMACAddress">
            <summary>
            	The destination MAC address. The Destination address specifies to 
            	which adapter the data frame is being sent. A Destination Address of 
            	all ones specifies a Broadcast Message that is read in
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.m_networkProtocol">
            <summary>
            	The network layer protocol.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.m_data">
            <summary>
            	Data.
            </summary>
        </member>
        <member name="M:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.#ctor">
            <summary>
            	Create a new ethernet 802.3 packet.
            </summary>
        </member>
        <member name="M:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.#ctor(System.Byte[])">
            <summary>
            	Create a new ethernet 802.3 packet.
            </summary>
            <param name="packet">
            	The ethernet packet to parse.
            </param>
        </member>
        <member name="M:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.Serialize">
            <summary>
            	Serialize the packet in to a byte array suitable for transmitting over
            	the network.
            </summary>
            <returns>
            	A byte array containing the fields.
            </returns>
        </member>
        <member name="P:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.SourceMACAddress">
            <summary>
            	The source MAC address. The Source address specifies from which 
            	adapter the message originated.
            </summary>
        </member>
        <member name="P:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.DestinationMACAddress">
            <summary>
            	The destination MAC address. The Destination address specifies to 
            	which adapter the data frame is being sent. A Destination Address of 
            	all ones specifies a Broadcast Message that is read in
            </summary>
        </member>
        <member name="P:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.NetworkProtocol">
            <summary>
            	The network layer protocol.
            </summary>
        </member>
        <member name="P:Metro.LinkLayer.Ethernet802_3.Ethernet802_3.Data">
            <summary>
            	The data above the ethernet layer.
            </summary>
        </member>
        <member name="T:Metro.LinkLayer.MACAddress">
            <summary>
            	Represents a MAC address.
            </summary>
        </member>
        <member name="F:Metro.LinkLayer.MACAddress.m_address">
            <summary>
            	The address.
            </summary>
        </member>
        <member name="M:Metro.LinkLayer.MACAddress.GetVender(System.Xml.XmlTextReader,Metro.LinkLayer.MACAddress)">
            <summary>
            	Returns the vendor given a MAC address.
            </summary>
            <param name="reader">
            	The XML text reader to use to read the file.
            	Use the oui.xml file included in the Data folder of the library or a
            	file with the same format. If the format is not correct then the
            	behaviour of this method is undefined. In other words, don't blame me
            	if it freezes or raises an exception, if you pass an incorrectly
            	formatted file.
            </param>
            <param name="address">
            	The MAC address whose vendor to find.
            </param>
            <returns>
            	The vendor name.
            </returns>
        </member>
        <member name="M:Metro.LinkLayer.MACAddress.#ctor(System.Byte[])">
            <summary>
            	Create a new MAC address.
            </summary>
            <param name="address">
            	The address.
            </param>
        </member>
        <member name="M:Metro.LinkLayer.MACAddress.#ctor(System.String)">
            <summary>
            	Create a new MAC address.
            </summary>
            <param name="address">
            	The address.
            </param>
        </member>
        <member name="M:Metro.LinkLayer.MACAddress.ToString">
            <summary>
            	Convert the address to a string.
            </summary>
            <returns>
            	The address in the format xx:xx:xx:xx:xx:xx
            </returns>
        </member>
        <member name="M:Metro.LinkLayer.MACAddress.ToString(System.Char)">
            <summary>
            	Convert the address to a string.
            </summary>
            <param name="seperator">
            	The character which seperates each byte in the IP.
            </param>
            <returns>
            	The address in the format xx:xx:xx:xx:xx:xx
            </returns>
        </member>
        <member name="P:Metro.LinkLayer.MACAddress.BroadcastAddress">
            <summary>
            	Return a suitable broadcast address.
            </summary>
        </member>
        <member name="P:Metro.LinkLayer.MACAddress.Address">
            <summary>
            	Return the address.
            </summary>
        </member>
        <member name="T:Metro.Logging.ArpLogger">
            <summary>
            	Provides logging for ARP packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.ArpLogger.m_logger">
            <summary>
            	The packet logger to use.
            </summary>
        </member>
        <member name="M:Metro.Logging.ArpLogger.#ctor(Metro.Logging.PacketLogger)">
            <summary>
            	Create a new ARP logger.
            </summary>
            <param name="logger">
            	The logger object to use.
            </param>
        </member>
        <member name="M:Metro.Logging.ArpLogger.LogPacket(Metro.NetworkLayer.ARP.ArpPacket)">
            <summary>
            	Log a new ARP packet.
            </summary>
            <param name="packet">
            	The packet to log.
            </param>
        </member>
        <member name="T:Metro.Logging.EthernetLogger">
            <summary>
            	Provides logging for ethernet packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.EthernetLogger.m_logger">
            <summary>
            	The packet logger to use.
            </summary>
        </member>
        <member name="M:Metro.Logging.EthernetLogger.#ctor(Metro.Logging.PacketLogger)">
            <summary>
            	Create a new ethernet  logger.
            </summary>
            <param name="logger">
            	The logger object to use.
            </param>
        </member>
        <member name="M:Metro.Logging.EthernetLogger.LogPacket(Metro.LinkLayer.Ethernet802_3.Ethernet802_3)">
            <summary>
            	Log a new ethernet packet.
            </summary>
            <param name="packet">
            	The packet to log.
            </param>
        </member>
        <member name="T:Metro.Logging.IcmpLogger">
            <summary>
            	Provides logging for ICMP packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.IcmpLogger.m_logger">
            <summary>
            	The packet logger to use.
            </summary>
        </member>
        <member name="M:Metro.Logging.IcmpLogger.#ctor(Metro.Logging.PacketLogger)">
            <summary>
            	Create a new ICMP logger.
            </summary>
            <param name="logger">
            	The logger object to use.
            </param>
        </member>
        <member name="M:Metro.Logging.IcmpLogger.LogPacket(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Log a new ICMP packet.
            </summary>
            <param name="packet">
            	The packet to log.
            </param>
        </member>
        <member name="T:Metro.Logging.IpV4Logger">
            <summary>
            	Provides logging for IP version 4 packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.IpV4Logger.m_logger">
            <summary>
            	The packet logger to use.
            </summary>
        </member>
        <member name="M:Metro.Logging.IpV4Logger.#ctor(Metro.Logging.PacketLogger)">
            <summary>
            	Create a new IP version 4 logger.
            </summary>
            <param name="logger">
            	The logger object to use.
            </param>
        </member>
        <member name="M:Metro.Logging.IpV4Logger.LogPacket(Metro.NetworkLayer.IpV4.IpV4Packet)">
            <summary>
            	Log a new IP packet.
            </summary>
            <param name="packet">
            	The packet to log.
            </param>
        </member>
        <member name="T:Metro.Logging.PacketLogger">
            <summary>
            	Provides very basic packet logging methods.
            </summary>
        </member>
        <member name="F:Metro.Logging.PacketLogger.m_writer">
            <summary>
            	The xml text writer to use to write to the log file.
            </summary>
        </member>
        <member name="F:Metro.Logging.PacketLogger.m_disposed">
            <summary>
            	Whether or not the class has been disposed or not.
            </summary>
        </member>
        <member name="F:Metro.Logging.PacketLogger.m_inUse">
            <summary>
            	Used to synchronize access to packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.PacketLogger.m_packetCount">
            <summary>
            	Used by Dispose methods to wait for all packets to finish writing.
            </summary>
        </member>
        <member name="M:Metro.Logging.PacketLogger.#ctor(System.Xml.XmlTextWriter)">
            <summary>
            	Create a new packet logger.
            </summary>
            <param name="writer">
            	The xml writer to use to write to the log.
            </param>
        </member>
        <member name="M:Metro.Logging.PacketLogger.#ctor(System.IO.Stream)">
            <summary>
            	Create a new packet logger.
            </summary>
            <param name="stream">
            	The stream to write the log to.
            </param>
        </member>
        <member name="M:Metro.Logging.PacketLogger.#ctor(System.String)">
            <summary>
            	Create a new packet logger.
            </summary>
            <param name="fileName">
            	The name of the file to log to.
            </param>
        </member>
        <member name="M:Metro.Logging.PacketLogger.BeginPacket">
            <summary>
            	Write the start tags of a new packet. This should be paired with a
            	EndPacket call.
            </summary>
        </member>
        <member name="M:Metro.Logging.PacketLogger.EndPacket">
            <summary>
            	Write the end tags of the packet. This should be paired with a
            	BeginPacket call.
            </summary>
        </member>
        <member name="M:Metro.Logging.PacketLogger.Dispose">
            <summary>
            	Dispose.
            </summary>
        </member>
        <member name="M:Metro.Logging.PacketLogger.Dispose(System.Boolean)">
            <summary>
            	Dispose.
            </summary>
            <param name="disposing">
            	If disposing equals true, the method has been called directly
            	or indirectly by a user's code. Managed and unmanaged resources
            	can be disposed.
            	If disposing equals false, the method has been called by the 
            	runtime from inside the finalizer and you should not reference 
            	other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:Metro.Logging.PacketLogger.Finalize">
            <summary>
            	Destructor.
            </summary>
        </member>
        <member name="P:Metro.Logging.PacketLogger.XmlWriter">
            <summary>
            	The xml text writer to use to write to the log file.
            </summary>
        </member>
        <member name="P:Metro.Logging.PacketLogger.Disposed">
            <summary>
            	Whether or not the class has been disposed or not.
            </summary>
        </member>
        <member name="T:Metro.Logging.TcpLogger">
            <summary>
            	Provides logging for TCP packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.TcpLogger.m_logger">
            <summary>
            	The packet logger to use.
            </summary>
        </member>
        <member name="M:Metro.Logging.TcpLogger.#ctor(Metro.Logging.PacketLogger)">
            <summary>
            	Create a new TCP  logger.
            </summary>
            <param name="logger">
            	The logger object to use.
            </param>
        </member>
        <member name="M:Metro.Logging.TcpLogger.LogPacket(Metro.TransportLayer.Tcp.TcpPacket)">
            <summary>
            	Log a new TCP packet.
            </summary>
            <param name="packet">
            	The packet to log.
            </param>
        </member>
        <member name="T:Metro.Logging.UdpLogger">
            <summary>
            	Provides logging for UDP packets.
            </summary>
        </member>
        <member name="F:Metro.Logging.UdpLogger.m_logger">
            <summary>
            	The packet logger to use.
            </summary>
        </member>
        <member name="M:Metro.Logging.UdpLogger.#ctor(Metro.Logging.PacketLogger)">
            <summary>
            	Create a new UDP logger.
            </summary>
            <param name="logger">
            	The logger object to use.
            </param>
        </member>
        <member name="M:Metro.Logging.UdpLogger.LogPacket(Metro.TransportLayer.Udp.UdpPacket)">
            <summary>
            	Log a new UDP packet.
            </summary>
            <param name="packet">
            	The packet to log.
            </param>
        </member>
        <member name="T:Metro.NetworkAdapter">
            <summary>
            	Represents a network interface which can be bound to by the NDIS
            	protocol driver.
            </summary>
        </member>
        <member name="F:Metro.NetworkAdapter.m_index">
            <summary>
            	Adapter index.
            </summary>
        </member>
        <member name="F:Metro.NetworkAdapter.m_adapterID">
            <summary>
            	Adapter id.
            </summary>
        </member>
        <member name="F:Metro.NetworkAdapter.m_adapterName">
            <summary>
            	Adapter name.
            </summary>
        </member>
        <member name="F:Metro.NetworkAdapter.m_macAddress">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.NetworkAdapter.m_interfaces">
            <summary>
            
            </summary>
        </member>
        <member name="P:Metro.NetworkAdapter.Index">
            <summary>
            	Adapter index.
            </summary>
        </member>
        <member name="P:Metro.NetworkAdapter.AdapterID">
            <summary>
            	Adapter id.
            </summary>
        </member>
        <member name="P:Metro.NetworkAdapter.AdapterName">
            <summary>
            	Adapter name.
            </summary>
        </member>
        <member name="P:Metro.NetworkAdapter.MediaAccessControlAddress">
            <summary>
            	MAC address associated with this device.
            </summary>
        </member>
        <member name="P:Metro.NetworkAdapter.Interfaces">
            <summary>
            	Network interface list
            </summary>
        </member>
        <member name="T:Metro.NdisProtocolDriverInterface">
            <summary>
            	A class used for interfacing with the NDIS protocol driver included in
            	the windows DDK.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.GENERIC_READ">
            <summary>
            	Used to open the device with read access.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.GENERIC_WRITE">
            <summary>
            	Used to open the device with write access.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.OPEN_EXISTING">
            <summary>
            	Open an existing device
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.FILE_ATTRIBUTE_NORMAL">
            <summary>
            	Normal file attributes.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.INVALID_HANDLE_VALUE">
            <summary>
            	represents an invalid handle.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.IOCTL_NDISPROT_QUERY_BINDING">
            <summary>
            	The control code used to query interfaces to bind to.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.IOCTL_NDISPROT_OPEN_DEVICE">
            <summary>
            	The control code used to bind to an interface.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.MAX_ADAPTER_NAME_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.MAX_ADAPTER_ADDRESS_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.MAX_ADAPTER_DESCRIPTION_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.ERROR_BUFFER_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.MIB_IF_TYPE_ETHERNET">
            <summary>
            
            </summary>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.CreateFile(System.String,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
             <summary>
            		The CreateFile function creates or opens a file, directory, physical disk, 
            		volume, console buffer, tape drive, communications resource, mailslot, or 
            		named pipe. The function returns a handle that can be used to access the 
            		object.
             </summary>
             <param name="_lpFileName">
            		Pointer to a null-terminated string that specifies the name of the object 
            		to create or open.
            	</param>
             <param name="_dwDesiredAccess">
            		Access to the object (reading, writing, or both).
            	</param>
             <param name="_dwShareMode">
            		Sharing mode of the object (reading, writing, both, or neither)
            	</param>
             <param name="_lpSecurityAttributes">
            		Pointer to a SECURITY_ATTRIBUTES structure that determines whether the 
            		returned handle can be inherited by child processes. If 
            		lpSecurityAttributes is NULL, the handle cannot be inherited.
            	</param>
             <param name="_dwCreationDisposition">
            		Action to take on files that exist, and which action to take when files do 
            		not exist. For more information about this parameter, see the Remarks 
            		section.
            	</param>
             <param name="_dwFlagsAndAttributes">
            		File attributes and flags.
            	</param>
             <param name="_hTemplateFile">
            		Handle to a template file, with the GENERIC_READ access right. The template
            		file supplies file attributes and extended attributes for the file being 
            		created. This parameter can be NULL.
            	</param>
             <returns>
            		If the function succeeds, the return value is an open handle to the 
            		specified file. If the specified file exists before the function call and 
            		dwCreationDisposition is CREATE_ALWAYS or OPEN_ALWAYS, a call to 
            		GetLastError returns ERROR_ALREADY_EXISTS (even though the function has 
            		succeeded). If the file does not exist before the call, GetLastError 
            		returns zero.
            
            		If the function fails, the return value is INVALID_HANDLE_VALUE. To get 
            		extended error information, call GetLastError.
            	</returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.WriteFile(System.IntPtr,System.Void*,System.UInt32,System.UInt32*,System.UInt32)">
            <summary>
            	The WriteFile function writes data to a file at the position specified by the 
            	file pointer. This function is designed for both synchronous and asynchronous 
            	operation.
            </summary>
            <param name="_hFile">
            	Handle to the file. The file handle must have been created with the GENERIC_WRITE
            	access right.
            </param>
            <param name="_lpBuffer">
            	Pointer to the buffer containing the data to be written to the file.
            </param>
            <param name="_nNumberOfBytesToWrite">
            	Number of bytes to be written to the file.
            </param>	
            <param name="_lpNumberOfBytesWritten">
            	Pointer to the variable that receives the number of bytes written. 
            </param>
            <param name="_lpOverlapped">
            	Pointer to an OVERLAPPED structure. This structure is required if hFile 
            	was opened with FILE_FLAG_OVERLAPPED.
            </param>
            <returns>
            	If the function succeeds, the return value is nonzero.
            	
            	If the function fails, the return value is zero. To get extended error 
            	information, call GetLastError.
            </returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.ReadFile(System.IntPtr,System.Void*,System.UInt32,System.UInt32*,System.UInt32)">
            <summary>
            	The ReadFile function reads data from a file, starting at the position 
            	indicated by the file pointer. This function is designed for both 
            	synchronous and asynchronous operation.
            </summary>
            <param name="_hFile">
            	Handle to the file. The file handle must have been created with the GENERIC_READ
            	access right.
            </param>
            <param name="_lpBuffer">
            	Pointer to the buffer that receives the data read from the file.
            </param>
            <param name="_nNumberOfBytesToRead">
            	Number of bytes to be read from the file.
            </param>	
            <param name="_lpNumberOfBytesRead">
            	ointer to the variable that receives the number of bytes read.
            </param>
            <param name="_lpOverlapped">
            	Pointer to an OVERLAPPED structure. This structure is required if hFile 
            	was opened with FILE_FLAG_OVERLAPPED.
            </param>
            <returns>
            	If the function succeeds, the return value is nonzero.
            	
            	If the function fails, the return value is zero. To get extended error 
            	information, call GetLastError.
            </returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.CloseHandle(System.IntPtr)">
             <summary>
            		The CloseHandle function closes an open object handle.
             </summary>
             <param name="_hObject">
            		Handle to an open object.
            	</param>
             <returns>
            		If the function succeeds, the return value is nonzero.
            
            		If the function fails, the return value is zero. To get extended error 
            		information, call GetLastError.
            	</returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.DeviceIoControl(System.IntPtr,System.UInt32,System.Void*,System.UInt32,System.Void*,System.UInt32,System.UInt32*,System.UInt32)">
            <summary>
            	The DeviceIoControl function sends a control code directly to a specified 
            	device driver, causing the corresponding device to perform the 
            	corresponding operation.
            </summary>
            <param name="_hDevice">
            	Handle to the device on which the operation is to be performed. The device 
            	is typically a volume, directory, file, or stream. To retrieve a device 
            	handle, use the CreateFile function.
            </param>
            <param name="_dwIoControlCode">
            	Control code for the operation. This value identifies the specific 
            	operation to be performed and the type of device on which to perform it.
            </param>
            <param name="_lpInBuffer">
            	Pointer to the input buffer that contains the data required to perform the 
            	operation. The format of this data depends on the value of the 
            	dwIoControlCode parameter.
            </param>
            <param name="_nInBufferSize">
            	Size of the input buffer, in bytes.
            </param>
            <param name="lpOutBuffer">
            	Pointer to the output buffer that is to receive the data returned by the 
            	operation. The format of this data depends on the value of the 
            	dwIoControlCode parameter.
            </param>
            <param name="_nOutBufferSize">
            	 Size of the output buffer, in bytes.
            </param>
            <param name="_lpBytesReturned">
            	Pointer to a variable that receives the size of the data stored in the 
            	output buffer, in bytes.
            </param>	
            <param name="_lpOverlapped">
            	Pointer to an OVERLAPPED structure.
            </param>
            <returns>
            	If the function succeeds, the return value is nonzero.
            	
            	If the function fails, the return value is zero. To get extended error 
            	information, call GetLastError.
            </returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.GetAdaptersInfo(System.IntPtr,System.Int32@)">
            <summary>
            	The GetAdaptersInfo function retrieves adapter information for the 
            	local computer.
            </summary>
            <param name="pAdapterInfo">
            	Pointer to a buffer that receives a linked list of IP_ADAPTER_INFO 
            	structures.
            </param>
            <param name="pOutBufLen">
            	Pointer to a ULONG variable that specifies the size of the buffer 
            	pointed to by the pAdapterInfo parameter. If this size is insufficient 
            	to hold the adapter information, GetAdaptersInfo fills in this variable
            	with the required size, and returns an error code of ERROR_BUFFER_OVERFLOW.
            </param>
            <returns>
            	If the function succeeds, the return value is ERROR_SUCCESS.
            </returns>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.m_hDevice">
            <summary>
            	The device handle.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.m_adapters">
            <summary>
            	Network adapters.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.m_boundAdapter">
            <summary>
            	The adapter which has been bound to.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.m_disposed">
            <summary>
            	Whether or not the class has been disposed.
            </summary>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.OpenDevice(System.String)">
            <summary>
            	Open the device driver.
            </summary>
            <param name="deviceName">
            	The device driver name.
            </param>
            <exception cref="T:System.SystemException">
            	A system error occured when opening the driver.
            </exception>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.CloseDevice">
            <summary>
            	Closes the device driver
            </summary>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.EnumerateAdapters">
            <summary>
            	Enumerate network adapters to bind to.
            </summary>
            <returns>
            	Returns an array of network adapters.
            </returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.BindAdapter(Metro.NetworkAdapter)">
            <summary>
            	Bind the driver to an adapter for use. Note that an adapter
            	can only be bound to by one driver at a time.
            </summary>
            <param name="adapter">
            	The adapter to bind to.
            </param>
            <exception cref="T:System.SystemException">
            	If the driver cannot be bound to, a system exception is thrown.
            </exception>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.BindAdapter(System.String)">
            <summary>
            	Bind the driver to an adapter for use. Note that an adapter
            	can only be bound to by one driver at a time.
            </summary>
            <param name="adapterID">
            	The adapter id to bind to.
            </param>
            <exception cref="T:System.SystemException">
            	If the driver cannot be bound to, a system exception is thrown.
            </exception>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.BindAdapter(Metro.NetworkInterface)">
            <summary>
            	Bind the driver to an adapter for use. Note that an adapter
            	can only be bound to by one driver at a time.
            </summary>
            <param name="networkInterface">
            	The network interface to bind to.
            </param>
            <exception cref="T:System.SystemException">
            	If the driver cannot be bound to, a system exception is thrown.
            </exception>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.BindAdapter(System.Net.IPAddress)">
            <summary>
            	Bind the driver to an adapter for use. Note that an adapter
            	can only be bound to by one driver at a time.
            </summary>
            <param name="networkInterface">
            	The network interface to bind to.
            </param>
            <exception cref="T:System.SystemException">
            	If the driver cannot be bound to, a system exception is thrown.
            </exception>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.SendPacket(System.Byte[])">
            <summary>
            	Write a packet to the network interface.
            </summary>
            <param name="packet">
            	The packet to write.
            </param>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.RecievePacket">
            <summary>
            	Recieve a packet from the network interface.
            </summary>
            <returns>
            	The recieved packet or null if it failed to recieve.
            </returns>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.Dispose">
            <summary>
            	Dispose.
            </summary>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.Dispose(System.Boolean)">
            <summary>
            	Dispose.
            </summary>
            <param name="disposing">
            	If disposing equals true, the method has been called directly
            	or indirectly by a user's code. Managed and unmanaged resources
            	can be disposed.
            	If disposing equals false, the method has been called by the 
            	runtime from inside the finalizer and you should not reference 
            	other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:Metro.NdisProtocolDriverInterface.Finalize">
            <summary>
            	Destructor.
            </summary>
        </member>
        <member name="P:Metro.NdisProtocolDriverInterface.DeviceHandle">
            <summary>
            	Returns the device handle.
            </summary>
        </member>
        <member name="P:Metro.NdisProtocolDriverInterface.Adapters">
            <summary>
            	Network adapter list.
            </summary>
        </member>
        <member name="P:Metro.NdisProtocolDriverInterface.DriverStarted">
            <summary>
            	Whether or not the driver has been successfuly started.
            </summary>
        </member>
        <member name="P:Metro.NdisProtocolDriverInterface.DriverBound">
            <summary>
            	Whether or not the driver has been successfuly bound to an adapter.
            </summary>
        </member>
        <member name="P:Metro.NdisProtocolDriverInterface.BoundAdapter">
            <summary>
            	The adapter which has been bound to, if any.
            </summary>
        </member>
        <member name="P:Metro.NdisProtocolDriverInterface.Disposed">
            <summary>
            	Whether or not the class has been disposed.
            </summary>
        </member>
        <member name="T:Metro.NdisProtocolDriverInterface.NDISPROT_QUERY_BINDING">
            <summary>
            	NDIS protocol query binding structure.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.NDISPROT_QUERY_BINDING.BindingIndex">
            <summary>
            	0 based binding number.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.NDISPROT_QUERY_BINDING.DeviceNameOffset">
            <summary>
            	Device name offset from start of the struct.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.NDISPROT_QUERY_BINDING.DeviceNameLength">
            <summary>
            	Device name length in bytes.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.NDISPROT_QUERY_BINDING.DeviceDescrOffset">
            <summary>
            	Device description offset from start of the struct.
            </summary>
        </member>
        <member name="F:Metro.NdisProtocolDriverInterface.NDISPROT_QUERY_BINDING.DeviceDescrLength">
            <summary>
             Device description length in bytes.
            </summary>
        </member>
        <member name="T:Metro.NetworkInterface">
            <summary>
            	This class stores information about a single network interface.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_address">
            <summary>
            	The IP address of the interface.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_subnetMask">
            <summary>
            	The subnet mask.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_broadcastAddress">
            <summary>
            	The broadcast address.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_enabled">
            <summary>
            	Whether or not this interface is up.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_loopback">
            <summary>
            	Whether or not this is the loopback interface.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_pointToPointLink">
            <summary>
            	Whether or not this is a point to point link.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_broadcast">
            <summary>
            	Whether or not this interface supports broadcasting.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_multiCast">
            <summary>
            	Whether or not this interface supports multicasting.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterface.m_interfaceIndex">
            <summary>
            	The interface index.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.Address">
            <summary>
            	The IP address of the interface.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.SubnetMask">
            <summary>
            	The subnet mask.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.BroadcastAddress">
            <summary>
            	The broadcast address.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.IsEnabled">
            <summary>
            	Whether or not this interface is up.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.isLoopback">
            <summary>
            	Whether or not this is the loopback interface.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.IsPointToPointLink">
            <summary>
            	Whether or not this is a point to point link.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.SupportsBroadcast">
            <summary>
            	Whether or not this interface supports broadcasting.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.SupportMulticast">
            <summary>
            	Whether or not this interface supports multicasting.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterface.InterfaceIndex">
            <summary>
            	The interface index.
            </summary>
        </member>
        <member name="T:Metro.NetworkInterfaceList">
            <summary>
            	This class will enumerate all network interfaces.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.ERROR_INSUFFICIENT_BUFFER">
            <summary>
            	Insufficient buffer size.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.SIO_GET_INTERFACE_LIST">
            <summary>
            	The input output control code for retrieving the interface list.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.m_socket">
            <summary>
            	The socket to perform the input output control on to retrieve the list.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.interfaces">
            <summary>
            	The array of network interfaces.
            </summary>
        </member>
        <member name="M:Metro.NetworkInterfaceList.GetIpAddrTable(System.IntPtr,System.Int32@,System.Boolean)">
            <summary>
            	The GetIpAddrTable function retrieves the interface–to–IP address 
            	mapping table.
            </summary>
            <param name="pIpAddrTable">
            	Pointer to a buffer that receives the interface–to–IP address mapping 
            	table as a MIB_IPADDRTABLE structure.
            </param>
            <param name="pdwSize">
            	On input, specifies the size of the buffer pointed to by the 
            	pIpAddrTable parameter.
            	On output, if the buffer is not large enough to hold the returned 
            	mapping table, the function sets this parameter equal to the required 
            	buffer size.
            </param>
            <param name="bOrder">
            	Specifies whether the returned mapping table should be sorted in 
            	ascending order by IP address. If this parameter is TRUE, the table is 
            	sorted.
            </param>
            <returns>
            	If the function succeeds, the return value is NO_ERROR.
            </returns>
        </member>
        <member name="M:Metro.NetworkInterfaceList.#ctor">
            <summary>
            	Create a new NetworkInterfaceList class.
            </summary>
            <exception cref="T:System.Exception">
            	Thrown when the network interface list could not be read.
            </exception>
        </member>
        <member name="M:Metro.NetworkInterfaceList.GetInterfaceByIndex(System.Int32)">
            <summary>
            	Returns a network interface by the interface index.
            </summary>
            <param name="interfaceIndex">
            	The interface index.
            </param>
            <returns>
            	The interface corresponding to the index or null if it couldn't be
            	found.
            </returns>
        </member>
        <member name="P:Metro.NetworkInterfaceList.Interfaces">
            <summary>
            	The array of network interfaces.
            </summary>
        </member>
        <member name="P:Metro.NetworkInterfaceList.Item(System.Int32)">
            <summary>
            	Returns a network interface.
            </summary>
        </member>
        <member name="T:Metro.NetworkInterfaceList.InterfaceInfoFlags">
            <summary>
            	Interface info flags.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.InterfaceInfoFlags.IIF_UP">
            <summary>
            	Interface is up.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.InterfaceInfoFlags.IIF_BROADCAST">
            <summary>
            	Broadcast is supported.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.InterfaceInfoFlags.IIF_LOOPBACK">
            <summary>
            	This is loopback interface.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.InterfaceInfoFlags.IIF_POINTTOPOINT">
            <summary>
            	This is point-to-point interface.
            </summary>
        </member>
        <member name="F:Metro.NetworkInterfaceList.InterfaceInfoFlags.IIF_MULTICAST">
            <summary>
            	Multicast is supported.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.MediaType">
            <summary>
            	The type of hardware.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Ethernet">
            <summary>
            	Ethernet.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.ExperimentalEthernet">
            <summary>
            	Experimental Ethernet.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.AmateurRadio">
            <summary>
            	Amateur Radio AX.25.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.TokenRing">
            <summary>
            	Proteon ProNET Token Ring.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Chaos">
            <summary>
            	Chaos.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.IEEE802">
            <summary>
            	IEEE 802
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.ARCNET">
            <summary>
            	ARCNET
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Hyperchannel">
            <summary>
            	Hyper Channel.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Lanstar">
            <summary>
            	Lanstar
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.AutonetShortAddress">
            <summary>
            	Autonet Short Address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.LocalTalk">
            <summary>
            		LocalTalk.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.LocalNet">
            <summary>
            	LocalNet (IBM PCNet or SYTEK LocalNET)
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.UltraLink">
            <summary>
            	Ultra Link.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.SMDS">
            <summary>
            	SMDS
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.FrameRelay">
            <summary>
            	Frame Relay.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.AsynchronousTransmissionMode">
            <summary>
            	ATM, Asynchronous Transmission Mode.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.HDLC">
            <summary>
            	HDLC.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.FibreChannel">
            <summary>
            	Fibre Channel.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.AsynchronousTransmissionMode2">
            <summary>
            	ATM, Asynchronous Transmission Mode.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.SerialLine">
            <summary>
            	Serial Line
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.AsynchronousTransmissionMode3">
            <summary>
            	ATM, Asynchronous Transmission Mode.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.MIL_STD_188_220">
            <summary>
            	MIL-STD-188-220.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Metricom">
            <summary>
            	Metricom.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.IEEE_1394_1995">
            <summary>
            	IEEE 1394.1995.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.MAPOS">
            <summary>
            	MAPOS.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Twinaxial">
            <summary>
            	Twinaxial.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.EUI_64">
            <summary>
            	EUI-64.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.HIPARP">
            <summary>
            	HIPARP.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.ISO_7816_3">
            <summary>
            	IP and ARP over ISO 7816-3.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.ARPSec">
            <summary>
            	ARPSec.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.IPsecTunnel">
            <summary>
            	IPsec tunnel
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.MediaType.Infiniband">
            <summary>
            	Infiniband.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.ArpOpcode">
            <summary>
            	The ARP opcode.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpOpcode.Request">
            <summary>
            	RFC 826
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpOpcode.Reply">
            <summary>
            	RFC 826, RFC 1868
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpOpcode.ReverseRequest">
            <summary>
            		RFC 903
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpOpcode.ReverseReply">
            <summary>
            		RFC 903
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.ArpPacket">
            <summary>
            	ARP is used to translate protocol addresses to hardware interface addresses.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_sourceMac">
            <summary>
            	Source MAC address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_destMac">
            <summary>
            	Destination MAC address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_sourceIP">
            <summary>
            	Source IP address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_destIP">
            <summary>
            	Destination IP address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_protocol">
            <summary>
            	Protocol type.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_hardware">
            <summary>
            	Hardware type.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpPacket.m_type">
            <summary>
            	ARP Type.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpPacket.#ctor">
            <summary>
            	Create a new ARP packet.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpPacket.#ctor(System.Byte[])">
            <summary>
            	Create a new ARP packet. 
            </summary>
            <param name="data">
            	The data representing the ARP packet.
            </param>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpPacket.Serialize">
            <summary>
            	
            </summary>
            <returns>
            
            </returns>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.SourceMACAddress">
            <summary>
            	Source MAC address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.DestinationMACAddress">
            <summary>
            	Destination MAC address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.SourceIPAddress">
            <summary>
            	Source IP address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.DestinationIPAddress">
            <summary>
            	Destination IP address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.MediaType">
            <summary>
            	Media type.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.Protocol">
            <summary>
            	Protocol.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpPacket.Type">
            <summary>
            	ARP Type.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.ArpSender">
            <summary>
            	The ArpSender class provides methods for sending ARP and RARP requests in order
            	to resolve an IP address to a physical address (using ARP) and vice versa (using
            	RARP).
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpSender.m_driver">
            <summary>
            	Create a new NDIS protocol driver interface class instance.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpSender.m_disposed">
            <summary>
            	Whether or not the class has been disposed.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpSender.m_querying">
            <summary>
            	Whether or not a query is being run.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpSender.#ctor(Metro.NdisProtocolDriverInterface)">
            <summary>
            	Create a new arp sender class.
            </summary>
            <param name="driver">
            	The NDIS protocol driver to use. The driver should already be
            	started up and bound to a device and be ready for use.
            </param>
            <exception cref="T:System.Exception">
            	If the driver fails to open, then an exception is raised.
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpSender.ResolveMACAddress(Metro.LinkLayer.MACAddress)">
            <summary>
            	Resolve a physical address to an IP address.
            </summary>
            <param name="address">
            	The physical address to resolve.
            </param>
            <returns>
            	Returns the IP address belonging to the physical address.
            </returns>
            <exception cref="T:System.ObjectDisposedException">
            	If the object has already been disposed then an ObjectDisposedException
            	will be thrown
            </exception>
            <exception cref="T:System.Exception">
            	If the driver failed to start or was not bound, an exception will be thrown.
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpSender.ResolveIPAddress(System.Net.IPAddress)">
            <summary>
            	Resolve an IP address to a physical address.
            </summary>
            <param name="address">
            	The IP address to resolve.
            </param>
            <returns>
            	Returns the physical address belonging to the IP address.
            </returns>
            <exception cref="T:System.ObjectDisposedException">
            	If the object has already been disposed then an ObjectDisposedException
            	will be thrown
            </exception>
            <exception cref="T:System.Exception">
            	If the driver failed to start or was not bound, an exception will be thrown.
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpSender.CancelQuery">
            <summary>
            	Cancel any pending queries.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpSender.Disposed">
            <summary>
            	Whether or not the class has been disposed yet,
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpSender.QueryPending">
            <summary>
            	Whether or not there is a query already running.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.ArpEntryType">
            <summary>
            	The type of ARP entry.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntryType.Other">
            <summary>
            	Other.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntryType.Invalid">
            <summary>
            	Invalid.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntryType.Dynamic">
            <summary>
            	Dynamic.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntryType.Static">
            <summary>
            	Static.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.ArpEntry">
            <summary>
            	Represents an entry in the ARP table.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntry.m_adapterIndex">
            <summary>
            	The adapter this entry belongs to.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntry.m_macAddress">
            <summary>
            	The physical address in the entry.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntry.m_ipAddress">
            <summary>
            	The IP address in the entry.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpEntry.m_type">
            <summary>
            	The type of this entry.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpEntry.AdapterIndex">
            <summary>
            	The adapter this entry is associated with.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpEntry.MediaAccessControlAddress">
            <summary>
            	The physical address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpEntry.IPAddress">
            <summary>
            	The IP address.
            </summary>	
        </member>
        <member name="P:Metro.NetworkLayer.ARP.ArpEntry.EntryType">
            <summary>
            	The entry type.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.ARP.ArpTable">
            <summary>
            	Reads the ARP table, used for storing IP address/MAC address pairings.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.ARP.ArpTable.ERROR_INSUFFICIENT_BUFFER">
            <summary>
            	Insufficient buffer space.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.GetIpNetTable(System.IntPtr,System.Int32@,System.Boolean)">
            <summary>
            	The GetIpNetTable function retrieves the IP-to-physical address mapping 
            	table.
            </summary>
            <param name="pIpNetTable">
            	Pointer to a buffer that receives the IP-to-physical address mapping 
            	table.
            </param>
            <param name="pdwSize">
            	On input, specifies the size of the buffer pointed to by the 
            	pIpNetTable parameter.
            	On output, if the buffer is not large enough to hold the returned 
            	mapping table, the function sets this parameter equal to the required 
            	buffer size.
            </param>
            <param name="bOrder">
            	Specifies whether the returned mapping table should be sorted in 
            	ascending order by IP address. If this parameter is TRUE, the table is 
            	sorted.
            </param>
            <returns>
            	If the function succeeds, the return value is NO_ERROR.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.FlushIpNetTable(System.Int32)">
            <summary>
            	The FlushIpNetTable function deletes all ARP entries for the specified 
            	interface from the ARP table on the local computer.
            </summary>
            <param name="dwIfIndex">
            	Index of the interface for which to delete all ARP entries.
            </param>
            <returns>
            	If the function succeeds, the return value is NO_ERROR.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.DeleteIpNetEntry(System.IntPtr)">
            <summary>
            	The DeleteIpNetEntry function deletes an ARP entry from the ARP table 
            	on the local computer.
            </summary>
            <param name="pArpEntry">
            	Pointer to a MIB_IPNETROW structure. The information in this structure 
            	specifies the entry to delete. The caller must specify values for at least 
            	the dwIndex and dwAddr members of this structure.
            </param>
            <returns>
            	If the function succeeds, the return value is NO_ERROR.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.SetIpNetEntry(System.IntPtr)">
            <summary>
            	The SetIpNetEntry function modifies an existing ARP entry in the ARP 
            	table on the local computer.
            </summary>
            <param name="pArpEntry">
            	Pointer to a MIB_IPNETROW structure. The information in this structure 
            	specifies the entry to modify and the new information for the entry. The 
            	caller must specify values for all members of this structure.
            </param>
            <returns>
            	If the function succeeds, the return value is NO_ERROR.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.CreateIpNetEntry(System.IntPtr)">
            <summary>
            	The CreateIpNetEntry function creates an Address Resolution Protocol 
            	(ARP) entry in the ARP table on the local computer.
            </summary>
            <param name="pArpEntry">
            	 Pointer to a MIB_IPNETROW structure that specifies information for 
            	the new entry. The caller must specify values for all members of this 
            	structure.
            </param>
            <returns>
            	If the function succeeds, the return value is NO_ERROR.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.CreateProxyArpEntry(System.Int32,System.Int32,System.Int32)">
             <summary>
            		The CreateProxyArpEnry function creates a Proxy Address Resolution 
            		Protocol (PARP) entry on the local computer for the specified IP 
            		address.
             </summary>
             <param name="dwAddress">
            		IP address for which this computer acts as a proxy.
            </param>
             <param name="dwMask">
            		Subnet mask for the IP address specified in dwAddress.
            	</param>
             <param name="dwIfIndex">
            		Index of the interface on which to proxy ARP for the IP address 
            		identified by dwAddress. In other words, when an ARP request for 
            		dwAddress is received on this interface, the local computer responds 
            		with the physical address of this interface. If this interface is of a 
            		type that does not support ARP, such as PPP, then the call fails.
            	</param>
             <returns>
            		If the function succeeds, the return value is NO_ERROR.
            	</returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.DeleteProxyArpEntry(System.Int32,System.Int32,System.Int32)">
             <summary>
            		The DeleteProxyArpEntry function deletes the PARP entry on the local 
            		computer specified by the dwAddress and dwIfIndex parameters.
             </summary>
             <param name="dwAddress">
            		IP address for which this computer acts as a proxy.
            </param>
             <param name="dwMask">
            		Subnet mask for the IP address specified in dwAddress.
            	</param>
             <param name="dwIfIndex">
            		Index of the interface on which this computer is supporting proxy ARP 
            		for the IP address specified by dwAddress.
            	</param>
             <returns>
            		If the function succeeds, the return value is NO_ERROR.
            	</returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.ReadArpTable">
            <summary>
            	Read the ARP table. Returns null if reading failed.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.FlushArpTable(System.Int32)">
            <summary>
            	Deletes all ARP entries for the specified interface from the ARP table 
            	on the local computer.
            </summary>
            <param name="adapterIndex">
            	Index of the interface for which to delete all ARP entries.
            </param>
            <returns>
            	Returns true for success, false otherwise.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.DeleteArpEntry(Metro.NetworkLayer.ARP.ArpEntry)">
            <summary>
            	Deletes an ARP entry from the ARP table on the local computer.
            </summary>
            <param name="entry">
            	The entry to delete. This must at least have valid fields for the
            	adapter index and IP address.
            </param>
            <returns>
            	Returns true for success, false otherwise.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.SetArpEntry(Metro.NetworkLayer.ARP.ArpEntry)">
            <summary>
            	Modifies an existing ARP entry in the ARP table on the local computer.
            </summary>
            <param name="entry">
            	The entry to modify. All fields must be valid.
            </param>
            <returns>
            	Returns true for success, false otherwise.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.CreateArpEntry(Metro.NetworkLayer.ARP.ArpEntry)">
            <summary>
            	Creates an Address Resolution Protocol (ARP) entry in the ARP table on 
            	the local computer.
            </summary>
            <param name="entry">
            	The entry to add. All fields must be valid.
            </param>
            <returns>
            	Returns true for success, false otherwise.
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.CreateProxyArpEntry(System.Net.IPAddress,System.Net.IPAddress,System.Int32)">
             <summary>
            		The CreateProxyArpEnry function creates a Proxy Address Resolution 
            		Protocol (PARP) entry on the local computer for the specified IP 
            		address.
             </summary>
             <param name="address">
            		IP address for which this computer acts as a proxy.
            </param>
             <param name="mask">
            		Subnet mask for the IP address specified in dwAddress.
            	</param>
             <param name="adapterIndex">
            		Index of the interface on which to proxy ARP for the IP address 
            		identified by dwAddress. In other words, when an ARP request for 
            		dwAddress is received on this interface, the local computer responds 
            		with the physical address of this interface. If this interface is of a 
            		type that does not support ARP, such as PPP, then the call fails.
            	</param>
             <returns>
            		If the function succeeds, the return value is true, or false otherwise
            	</returns>
        </member>
        <member name="M:Metro.NetworkLayer.ARP.ArpTable.DeleteProxyArpEntry(System.Net.IPAddress,System.Net.IPAddress,System.Int32)">
             <summary>
            		The DeleteProxyArpEntry function deletes the PARP entry on the local 
            		computer specified by the dwAddress and dwIfIndex parameters.
             </summary>
             <param name="address">
            		IP address for which this computer acts as a proxy.
            </param>
             <param name="mask">
            		Subnet mask for the IP address specified in dwAddress.
            	</param>
             <param name="adapterIndex">
            		Index of the interface on which this computer is supporting proxy ARP 
            		for the IP address specified by dwAddress.
            	</param>
             <returns>
            		If the function succeeds, the return value is NO_ERROR.
            	</returns>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4Defragmentor">
            <summary>
            	Packets are passed to this class, reassembled if they are fragmented,
            	and then passed on via the IpV4PacketArrived event.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Defragmentor.m_packets">
            <summary>
            
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Defragmentor.HandleNewPacket(Metro.NetworkLayer.IpV4.IpV4Packet)">
            <summary>
            	Whenever a new IP packet arrives it should be passed to this method.
            	If the packet is fragmented it will be buffered until all of the other
            	fragments have arrived, then it will be pieced back together into a whole
            	packet.
            </summary>
            <param name="packet">
            	The packet which has arrived.
            </param>
        </member>
        <member name="E:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpV4PacketArrived">
            <summary>
            	The handler for when a new complete packet has arrived. This does not fire when
            	fragmented packets arrive. It will fire once all the fragments have arrived and have
            	been assembled back into a whole packet.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType">
            <summary>
            	This class stores information about a single set of IP fragments 
            	that belong together.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType.m_fragments">
            <summary>
            	The fragments that are all part of one packet.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType.m_totalDataSize">
            <summary>
            	The total size of the data we are waiting on. This is calculated when
            	we recieve the last fragment (which may not always arrive last since
            	order is not guaranteed with IP).
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType.m_currentDataSize">
            <summary>
            	The size of the data that has been recieved so far. Once this is equal to 
            	the total size, all fragments have been recieved and can be pieced together.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType.Fragments">
            <summary>
            	The fragments that are all part of one packet.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType.TotalDataSize">
            <summary>
            	The total size of the data we are waiting on. This is calculated when
            	we recieve the last fragment (which may not always arrive last since
            	order is not guaranteed with IP).
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Defragmentor.IpFragmentsType.CurrentDataSize">
            <summary>
            	The size of the data that has been recieved so far. Once this is equal to 
            	the total size, all fragments have been recieved and can be pieced together.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType">
            <summary>
            	Specifies one of 16 levels of security (eight of which are
            	reserved for future use).
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Unclassified">
            <summary>
            	Unclassified - 00000000 00000000
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Confidential">
            <summary>
            	Confidential - 11110001 00110101
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.EFTO">
            <summary>
            	EFTO - 01111000 10011010
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.MMMM">
            <summary>
            	MMMM - 10111100 01001101
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.PROG">
            <summary>
            	PROG - 01011110 00100110
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Restricted">
            <summary>
            	Restricted - 10101111 00010011
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Secret">
            <summary>
            	Secret - 11010111 10001000
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.TopSecret">
            <summary>
            	Top Secret - 01101011 11000101
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved1">
            <summary>
            	(Reserved for future use) - 00110101 11100010
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved2">
            <summary>
            	(Reserved for future use) - 10011010 11110001
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved3">
            <summary>
            	(Reserved for future use) - 01001101 01111000
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved4">
            <summary>
            	(Reserved for future use) - 00100100 10111101
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved5">
            <summary>
            	(Reserved for future use) - 00010011 01011110
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved6">
            <summary>
            	(Reserved for future use) - 10001001 10101111
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved7">
            <summary>
            	(Reserved for future use) - 11000100 11010110
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityLevelType.Reserved8">
            <summary>
            	(Reserved for future use) - 11100010 01101011
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4TimestampType">
            <summary>
            	Timestamp option types.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimestampType.TimestampsOnly">
            <summary>
            	Time stamps only, stored in consecutive 32-bit words.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimestampType.TimestampAndAddress">
            <summary>
            	Each timestamp is preceded with internet address of the
            	registering entity.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimestampType.PrespecifiedAddresses">
            <summary>
            	The internet address fields are prespecified.  An IP
            	module only registers its timestamp if it matches its own
            	address with the next specified internet address.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4SecurityOption">
            <summary>
            	This option provides a way for hosts to send security,
            	compartmentation, handling restrictions, and TCC (closed user
            	group) parameters.  The format for this option is as follows:
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityOption.m_level">
            <summary>
            	Specifies one of 16 levels of security (eight of which are
            	reserved for future use).
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityOption.m_compartment">
            <summary>
            	An all zero value is used when the information transmitted is
            	not compartmented. Other values for the compartments field
            	may be obtained from the Defense Intelligence Agency.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityOption.m_handling">
            <summary>
            	The values for the control and release markings are
            	alphanumeric digraphs and are defined in the Defense
            	Intelligence Agency Manual DIAM 65-19, "Standard Security
            	Markings".
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4SecurityOption.m_tcc">
            <summary>
            	Provides a means to segregate traffic and define controlled
            	communities of interest among subscribers. The TCC values are
            	trigraphs, and are available from HQ DCA Code 530.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4SecurityOption.#ctor">
            <summary>
            	Create a new security option.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4SecurityOption.#ctor(Metro.NetworkLayer.IpV4.IpV4Option)">
            <summary>
            	Create a new security option.
            </summary>
            <param name="option">
            	The option to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	The option argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The option argument is not a security option.
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4SecurityOption.Serialize">
            <summary>
            	Serlialize this routing option into something which
            	can be passed to an IpV4Packet class.
            </summary>
            <returns>	
            	An IpV4Option class which can be passed to an IpV4Packet.
            </returns>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4SecurityOption.SecurityLevel">
            <summary>
            	Specifies one of 16 levels of security (eight of which are
            	reserved for future use).
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4SecurityOption.Compartment">
            <summary>
            	An all zero value is used when the information transmitted is
            	not compartmented.  Other values for the compartments field
            	may be obtained from the Defense Intelligence Agency.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4SecurityOption.HandlingRestrictions">
            <summary>
            	The values for the control and release markings are
            	alphanumeric digraphs and are defined in the Defense
            	Intelligence Agency Manual DIAM 65-19, "Standard Security
            	Markings".
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4SecurityOption.TransmissionControlCode">
            <summary>
            	Provides a means to segregate traffic and define controlled
            	communities of interest among subscribers. The TCC values are
            	trigraphs, and are available from HQ DCA Code 530.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4RoutingOption">
            <summary>
            	This option provides routing and route recording.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4RoutingOption.m_pointer">
            <summary>
            	The third octet is the pointer into the route data
            	indicating the octet which begins the next source address to be
            	processed. The pointer is relative to this option, and the
            	smallest legal value for the pointer is 4.
            	If the pointer is greater than the length, the source route is empty 
            	(and the recorded route full) and the routing is to be based on the
            	destination address field.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4RoutingOption.m_routeData">
            <summary>
            	A route data is composed of a series of internet addresses.
            	Each internet address is 32 bits or 4 octets.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4RoutingOption.#ctor">
            <summary>
            	Create a new routing option.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4RoutingOption.#ctor(Metro.NetworkLayer.IpV4.IpV4Option)">
            <summary>
            	Create a new routing option.
            </summary>
            <param name="option">
            	The option to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	The option argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The option argument is not a routing option.
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4RoutingOption.Serialize(Metro.NetworkLayer.IpV4.IpV4OptionNumber)">
            <summary>
            	Serlialize this routing option into something which
            	can be passed to an IpV4Packet class.
            </summary>
            <param name="optionType">
            	There are 3 types of routing option: loose source, strict source and record.
            </param>
            <returns>	
            	An IpV4Option class which can be passed to an IpV4Packet.
            </returns>
            <exception cref="T:System.ArgumentException">
            	The option type is not a routing option.
            </exception>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4RoutingOption.Pointer">
            <summary>
            	The third octet is the pointer into the route data
            	indicating the octet which begins the next source address to be
            	processed. The pointer is relative to this option, and the
            	smallest legal value for the pointer is 4.
            	If the pointer is greater than the length, the source route is empty 
            	(and the recorded route full) and the routing is to be based on the
            	destination address field.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4RoutingOption.Route">
            <summary>
            	A route data is composed of a series of internet addresses.
            	Each internet address is 32 bits or 4 octets.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption">
            <summary>
            	This option provides a way for the 16-bit SATNET stream
            	identifier to be carried through networks that do not support
            	the stream concept.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption.m_random">
            <summary>
            	Used for generating random numbers.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption.m_id">
            <summary>
            	A 16-bit SATNET stream identifier.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption.#ctor">
            <summary>
            	Create a new stream identifier option.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption.#ctor(Metro.NetworkLayer.IpV4.IpV4Option)">
            <summary>
            	Create a new stream identifier option.
            </summary>
            <param name="option">
            	The option to parse.
            </param>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption.Serialize">
            <summary>
            	Serlialize this routing option into something which
            	can be passed to an IpV4Packet class.
            </summary>
            <returns>	
            	An IpV4Option class which can be passed to an IpV4Packet.
            </returns>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4StreamIdentifierOption.StreamIdentifier">
            <summary>
            	A 16-bit SATNET stream identifier.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4TimeStampOption">
            <summary>
            	Internet Timestamp.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.m_pointer">
            <summary>
            	The Pointer is the number of octets from the beginning of this
            	option to the end of timestamps plus one (i.e., it points to the
            	octet beginning the space for next timestamp). The smallest
            	legal value is 5. The timestamp area is full when the pointer
            	is greater than the length.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.m_overflow">
            <summary>
            	The Overflow (oflw) [4 bits] is the number of IP modules that
            	cannot register timestamps due to lack of space.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.m_type">
            <summary>
            	The type of the time stamp data.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.m_timestamps">
            <summary>
            	The Timestamp is a right-justified, 32-bit timestamp in
            	milliseconds since midnight UT. If the time is not available in
            	milliseconds or cannot be provided with respect to midnight UT
            	then any time may be inserted as a timestamp provided the high
            	order bit of the timestamp field is set to one to indicate the
            	use of a non-standard value.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.m_addressstamps">
            <summary>
            	The address fields matching up to the time stamp fields
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.#ctor">
            <summary>
            	Create a new time stamp option.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.#ctor(Metro.NetworkLayer.IpV4.IpV4Option)">
            <summary>
            	Create a new time stamp option.
            </summary>
            <param name="option">
            	The option to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	The option argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The option argument is not a timestamp option.
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.Serialize">
            <summary>
            	Serlialize this routing option into something which
            	can be passed to an IpV4Packet class.
            </summary>
            <returns>	
            	An IpV4Option class which can be passed to an IpV4Packet.
            </returns>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.Pointer">
            <summary>
            	The Pointer is the number of octets from the beginning of this
            	option to the end of timestamps plus one (i.e., it points to the
            	octet beginning the space for next timestamp). The smallest
            	legal value is 5. The timestamp area is full when the pointer
            	is greater than the length.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.Overflow">
            <summary>
            	The Overflow (oflw) [4 bits] is the number of IP modules that
            	cannot register timestamps due to lack of space.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.OptionType">
            <summary>
            	The type of the time stamp data.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.Timestamps">
            <summary>
            	The Timestamp is a right-justified, 32-bit timestamp in
            	milliseconds since midnight UT. If the time is not available in
            	milliseconds or cannot be provided with respect to midnight UT
            	then any time may be inserted as a timestamp provided the high
            	order bit of the timestamp field is set to one to indicate the
            	use of a non-standard value.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TimeStampOption.Addressstamps">
            <summary>
            	The address fields matching up to the time stamp fields
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4PacketArrivedHandler">
            <summary>
            	The handler for when a new packet has arrived.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4OptionClass">
            <summary>
            	The option class.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionClass.Control">
            <summary>
            	Control options.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionClass.Reserved1">
            <summary>
            	Reserved for future use.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionClass.DebuggingAndMeasurement">
            <summary>
            	Degugging and measurement options.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionClass.Reserved2">
            <summary>
            	Reserved for future use.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4OptionNumber">
            <summary>
            	The type of option.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.EndOfOptions">
            <summary>
            	This option occupies only 1 octet; it has no length octet.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.NoOperation">
            <summary>
            	This option occupies only 1 octet; it has no length octet.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.Security">
            <summary>
            	Used to carry Security, Compartmentation, User Group (TCC), and
            	Handling Restriction Codes compatible with DOD equirements.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.LooseSourceRouting">
            <summary>
            	Used to route the internet datagram based on information
            	supplied by the source.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.InternetTimestamp">
            <summary>
            	Internet Timestamp
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.RecordRoute">
            <summary>
            	Used to trace the route an internet datagram takes.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.StreamId">
            <summary>
            	Used to carry the stream identifier.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4OptionNumber.StrictSourceRouting">
            <summary>
            	Strict Source Routing.  Used to route the internet datagram based 
            	on information supplied by the source.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4PrecedenceType">
            <summary>
            	An independent measure of the importance of this datagram.
            	Several networks offer service precedence, which somehow treats high
            	precedence traffic as more important than other traffic (generally
            	by accepting only traffic above a certain precedence at time of high
            	load).
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.Routine">
            <summary>
            	Routine traffic. This is the most widely used. Use this when in doubt.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.Priority">
            <summary>
            	Priority.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.Immediate">
            <summary>
            	Immediate.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.Flash">
            <summary>
            	Flash.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.FlashOverride">
            <summary>
            	Flash Override.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.CriticECP">
            <summary>
            	Critic/ECP.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.InternetworkControl">
            <summary>
            	Internetwork Control.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4PrecedenceType.NetworkControl">
            <summary>
            	Network Control.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4DelayType">
            <summary>
            	Prompt delivery is important for datagrams with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4DelayType.Normal">
            <summary>
            	Normal.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4DelayType.Low">
            <summary>
            	Low.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4ThroughputType">
            <summary>
            	High data rate is important for datagrams with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ThroughputType.Normal">
            <summary>
            	Normal.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ThroughputType.High">
            <summary>
            	High.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4ReliabilityType">
            <summary>
            	A higher level of effort to ensure delivery is important for datagrams 
            	with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ReliabilityType.Normal">
            <summary>
            	Normal.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ReliabilityType.High">
            <summary>
            	High.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType">
            <summary>
            	This class describes the type of service field in the IP header which
            	The type of service (TOS) is for internet service quality selection.
            	The type of service is specified along the abstract parameters
            	precedence, delay, throughput, and reliability. These abstract
            	parameters are to be mapped into the actual service parameters of
            	the particular networks the datagram traverses.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.m_precedence">
            <summary>
            	An independent measure of the importance of this datagram.
            	Several networks offer service precedence, which somehow treats high
            	precedence traffic as more important than other traffic (generally
            	by accepting only traffic above a certain precedence at time of high
            	load).
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.m_delay">
            <summary>
            	Prompt delivery is important for datagrams with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.m_throughput">
            <summary>
            	High data rate is important for datagrams with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.m_reliability">
            <summary>
            	A higher level of effort to ensure delivery is important for datagrams 
            	with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.Precedence">
            <summary>
            	An independent measure of the importance of this datagram.
            	Several networks offer service precedence, which somehow treats high
            	precedence traffic as more important than other traffic (generally
            	by accepting only traffic above a certain precedence at time of high
            	load).
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.Delay">
            <summary>
            	Prompt delivery is important for datagrams with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.Throughput">
            <summary>
            	High data rate is important for datagrams with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4TypeOfServiceType.Reliability">
            <summary>
            	A higher level of effort to ensure delivery is important for datagrams 
            	with this indication.
            	The use of the Delay, Throughput, and Reliability indications may
            	increase the cost (in some sense) of the service. In many networks
            	better performance for one of these parameters is coupled with worse
            	performance on another. Except for very unusual cases at most two
            	of these three indications should be set.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4ControlFlags">
            <summary>
            	Various Control Flags.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ControlFlags.m_doNotFragment">
            <summary>
            	An identifying value assigned by the sender to aid in assembling the
            	fragments of a datagram. If this is set then the packet will not be
            	fragmented.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ControlFlags.m_moreFragments">
            <summary>
            	An identifying value assigned by the sender to aid in assembling the
            	fragments of a datagram. If this is set then the packet is fragmented.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4ControlFlags.m_fragmentationOffset">
            <summary>
            	This field indicates where in the datagram this fragment belongs.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4ControlFlags.DontFragment">
            <summary>
            	An identifying value assigned by the sender to aid in assembling the
            	fragments of a datagram. If this is set then the packet will not be
            	fragmented.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4ControlFlags.MoreFragments">
            <summary>
            	An identifying value assigned by the sender to aid in assembling the
            	fragments of a datagram. If this is set then the packet is fragmented.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4ControlFlags.Offset">
            <summary>
            	This field indicates where in the datagram this fragment belongs.
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4Option">
            <summary>
            	The options may appear or not in datagrams.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Option.m_copied">
            <summary>
            	If the copied field is set to true then the option is copied to all
            	fragments of the packet.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Option.m_class">
            <summary>
            	The option class.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Option.m_number">
            <summary>
            	The option type.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Option.m_length">
            <summary>
            	The length of the option including the option type field and the
            	length field.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Option.m_data">
            <summary>
            	The data stored in the option. This is parsed by specific option
            	classes
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Option.IsCopied">
            <summary>
            	If the copied field is set to true then the option is copied to all
            	fragments of the packet.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Option.Class">
            <summary>
            	The option class.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Option.OptionType">
            <summary>
            	The option type.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Option.Length">
            <summary>
            	The length of the option including the option type field and the
            	length field.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Option.Data">
            <summary>
            	The data stored in the option. This is parsed by specific option
            	classes
            </summary>
        </member>
        <member name="T:Metro.NetworkLayer.IpV4.IpV4Packet">
            <summary>
            	This class is used for working with version 4 of the internet protocol.
            	The Internet Protocol is designed for use in interconnected systems of
            	packet-switched computer communication networks.  Such a system has
            	been called a "catenet" [1].  The internet protocol provides for
            	transmitting blocks of data called datagrams from sources to
            	destinations, where sources and destinations are hosts identified by
            	fixed length addresses.  The internet protocol also provides for
            	fragmentation and reassembly of long datagrams, if necessary, for
            	transmission through "small packet" networks.
            </summary>
            <remarks>
            	Note that this class will fully handle fragmentation when used in
            	parallel with the IpV4Defragmentor class.
            </remarks>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_random">
            <summary>
            	Used for generating random numbers.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_version">
            <summary>
            	The Version field indicates the format of the internet header. This
            	class uses version 4.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_headerLength">
            <summary>
            	Internet Header Length is the length of the internet header in octets,
            	and thus points to the beginning of the data. Note that the minimum 
            	value for a correct header is 20 octets.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_tos">
            <summary>
            	The type of service (TOS) is for internet service quality selection.
            	The type of service is specified along the abstract parameters
            	precedence, delay, throughput, and reliability. These abstract
            	parameters are to be mapped into the actual service parameters of
            	the particular networks the datagram traverses.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_totalLength">
            <summary>
            	Total Length is the length of the datagram, measured in octets,
            	including internet header and data. This field allows the length of
            	a datagram to be up to 65,535 octets. Such long datagrams are
            	impractical for most hosts and networks. All hosts must be prepared
            	to accept datagrams of up to 576 octets (whether they arrive whole
            	or in fragments). It is recommended that hosts only send datagrams
            	larger than 576 octets if they have assurance that the destination
            	is prepared to accept the larger datagrams.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_id">
            <summary>
            	An identifying value assigned by the sender to aid in assembling the
            	fragments of a datagram.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_icf">
            <summary>
            	Various Control Flags.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_ttl">
            <summary>
            	This field indicates the maximum time the datagram is allowed to
            	remain in the internet system. If this field contains the value
            	zero, then the datagram must be destroyed. This field is modified
            	in internet header processing. The time is measured in units of
            	seconds, but since every module that processes a datagram must
            	decrease the TTL by at least one even if it process the datagram in
            	less than a second, the TTL must be thought of only as an upper
            	bound on the time a datagram may exist. The intention is to cause
            	undeliverable datagrams to be discarded, and to bound the maximum
            	datagram lifetime.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_protocol">
            <summary>
            	This field indicates the next level protocol used in the data
            	portion of the internet datagram.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_checksum">
             <summary>
            		A checksum on the header only. Since some header fields change
            		(e.g., time to live), this is recomputed and verified at each point
            		that the internet header is processed.
            
            		The checksum field is the 16 bit one's complement of the one's
                 complement sum of all 16 bit words in the header. For purposes of
                 computing the checksum, the value of the checksum field is zero.
             </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_sourceAddress">
            <summary>
            	The source address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_destAddress">
            <summary>
            	The destination address.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_options">
            <summary>
            	Optional fields.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_padding">
            <summary>
            	The internet header padding is used to ensure that the internet
            	header ends on a 32 bit boundary.  The padding is zero.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_data">
            <summary>
            	All data above the IP header is placed in this buffer.
            </summary>
        </member>
        <member name="F:Metro.NetworkLayer.IpV4.IpV4Packet.m_fragments">
            <summary>
            	If this packet was assembled from fragments, this field contains how 
            	many fragments it contained.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Packet.#ctor">
            <summary>
            	Create a new IPv4 packet.
            </summary>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Packet.#ctor(Metro.NetworkLayer.IpV4.IpV4Packet[])">
            <summary>
            	Create a new IPv4 packet.
            </summary>
            <param name="packetFragments">
            	The fragments from a fragmented packet which will be peiced together
            	into a whole single packet.
            </param>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Packet.#ctor(System.Byte[])">
            <summary>
            	Create a new IPv4 packet.
            </summary>
            <param name="data">
            	The byte array representing the IP packet.
            </param>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Packet.Serialize">
            <summary>
            	This method will calculate fields such as the checksum, the total length
            	and the header length then pack the fields into a byte array in the format of
            	an ip header. This can then be given a transport layer and data and then transmitted 
            	over the internet.
            </summary>
            <returns>
            	The return value is a byte array with the ip header at the beginning which can be
            	written straight to a raw socket for transmission over the internet,
            </returns>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Packet.Fragment(System.Int32)">
            <summary>
            	The fragment method will turn this IP packet into several using fragmentation.
            </summary>
            <param name="maximumTransmissionUnit">
            	The maximum size of the data in each fragment. The maximum transmission unit must
            	be a multiple of 8. For example 8, 16, 24, 32 etc.
            </param>
            <returns>
            	This method returns an array of fragmented IP packets which can be sent over the
            	network.
            </returns>
            <exception cref="T:System.ArgumentException">
            	The MTU (maximum Transmission Unit) must be a multiple of 8 bytes
            </exception>
        </member>
        <member name="M:Metro.NetworkLayer.IpV4.IpV4Packet.ToString">
            <summary>
            	Return the string representation of this class
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Version">
            <summary>
            	The Version field indicates the format of the internet header. This
            	class uses version 4.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	The version must be version 4.
            </exception>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.HeaderLength">
            <summary>
            	Internet Header Length is the length of the internet header in octets,
            	and thus points to the beginning of the data. Note that the minimum 
            	value for a correct header is 20 octets.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	The header length was either too small or too large. The header length must
            	be between 20 and 60 bytes (Within the interval [20, 60]).
            </exception>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.TypeOfService">
            <summary>
            	The type of service (TOS) is for internet service quality selection.
            	The type of service is specified along the abstract parameters
            	precedence, delay, throughput, and reliability. These abstract
            	parameters are to be mapped into the actual service parameters of
            	the particular networks the datagram traverses.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.TotalLength">
            <summary>
            	Total Length is the length of the datagram, measured in octets,
            	including internet header and data. This field allows the length of
            	a datagram to be up to 65,535 octets. Such long datagrams are
            	impractical for most hosts and networks. All hosts must be prepared
            	to accept datagrams of up to 576 octets (whether they arrive whole
            	or in fragments). It is recommended that hosts only send datagrams
            	larger than 576 octets if they have assurance that the destination
            	is prepared to accept the larger datagrams.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Identification">
            <summary>
            	An identifying value assigned by the sender to aid in assembling the
            	fragments of a datagram.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.ControlFlags">
            <summary>
            	Various Control Flags.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.TimeToLive">
            <summary>
            	This field indicates the maximum time the datagram is allowed to
            	remain in the internet system. If this field contains the value
            	zero, then the datagram must be destroyed. This field is modified
            	in internet header processing. The time is measured in units of
            	seconds, but since every module that processes a datagram must
            	decrease the TTL by at least one even if it process the datagram in
            	less than a second, the TTL must be thought of only as an upper
            	bound on the time a datagram may exist. The intention is to cause
            	undeliverable datagrams to be discarded, and to bound the maximum
            	datagram lifetime.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.TransportProtocol">
            <summary>
            	This field indicates the next level protocol used in the data
            	portion of the internet datagram.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Checksum">
             <summary>
            		A checksum on the header only. Since some header fields change
            		(e.g., time to live), this is recomputed and verified at each point
            		that the internet header is processed.
            
            		The checksum field is the 16 bit one's complement of the one's
                 complement sum of all 16 bit words in the header. For purposes of
                 computing the checksum, the value of the checksum field is zero.
             </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.SourceAddress">
            <summary>
            	The source address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.DestinationAddress">
            <summary>
            	The destination address.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Options">
            <summary>
            
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Padding">
            <summary>
            	The internet header padding is used to ensure that the internet
            	header ends on a 32 bit boundary.  The padding is zero.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Data">
            <summary>
            	All the data above the IP header is placed in this buffer.
            </summary>
        </member>
        <member name="P:Metro.NetworkLayer.IpV4.IpV4Packet.Fragments">
            <summary>
            	If this packet was assembled from fragments then this field contains
            	how many fragments it was made from.
            </summary>
        </member>
        <member name="T:Metro.SnifferModeType">
            <summary>
            	The mode to work in.
            </summary>
        </member>
        <member name="F:Metro.SnifferModeType.Blocking">
            <summary>
            	Blocking mode, for console applications or seperate threads.
            </summary>
        </member>
        <member name="F:Metro.SnifferModeType.Asynchronous">
            <summary>
            	Asynchronous mode, for GUI threads.
            </summary>
        </member>
        <member name="T:Metro.NewPacketHandler">
            <summary>
            	The handler for the event which occurs when a new raw packet arrives
            </summary>
        </member>
        <member name="T:Metro.PacketSniffer">
            <summary>
            	A packet sniffer class, allowing packet sniffing on an interface down to the
            	network layer.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.SECURITY_BUILTIN_DOMAIN_RID">
            <summary>
            	SECURITY_BUILTIN_DOMAIN_RID.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.DOMAIN_ALIAS_RID_ADMINS">
            <summary>
            	DOMAIN_ALIAS_RID_ADMINS.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.RecieveAll">
            <summary>
            	The option for recieving all packets.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.m_isRunning">
            <summary>
            	Whether or not the sniffer is running.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.m_mode">
            <summary>
            	The mode to run in.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.m_bytesReceived">
            <summary>
            	The number of bytes recieved.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.m_state">
            <summary>
            	The state object.
            </summary>
        </member>
        <member name="M:Metro.PacketSniffer.AllocateAndInitializeSid(System.Byte[],System.Byte,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            The AllocateAndInitializeSid function allocates and initializes a security 
            identifier (SID) with up to eight subauthorities.
            </summary>
            <param name="pIdentifierAuthority">
            	Pointer to a SID_IDENTIFIER_AUTHORITY structure, giving the top-level 
            	identifier authority value to set in the SID.
            </param>
            <param name="nSubAuthorityCount">
            	Specifies the number of subauthorities to place in the SID. This parameter 
            	also identifies how many of the subauthority parameters have meaningful 
            	values. This parameter must contain a value from 1 to 8.
            </param>
            <param name="dwSubAuthority0">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority1">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority2">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority3">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority4">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority5">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority6">
            	Subauthority value to place in the SID.
            </param>
            <param name="dwSubAuthority7">
            	Subauthority value to place in the SID.
            </param>
            <param name="pSid">
            	Pointer to a variable that receives the pointer to the allocated and 
            	initialized SID structure.
            </param>
            <returns>
            	If the function succeeds, the return value is nonzero. If the function 
            	fails, the return value is zero. To get extended error information, call 
            	GetLastError.
            </returns>
        </member>
        <member name="M:Metro.PacketSniffer.CheckTokenMembership(System.IntPtr,System.IntPtr,System.Int32@)">
             <summary>
            		The CheckTokenMembership function determines whether a specified SID 
            		is enabled in an access token.
             </summary>
             <param name="TokenHandle">
            		Handle to an access token. The handle must have TOKEN_QUERY access to 
            		the token. The token must be an impersonation token.
            </param>
             <param name="SidToCheck">
            		Pointer to a SID structure. The CheckTokenMembership function checks 
            		for the presence of this SID in the user and group SIDs of the access 
            		token.
            	</param>
             <param name="IsMember">
            		Pointer to a variable that receives the results of the check. If the 
            		SID is present and has the SE_GROUP_ENABLED attribute, IsMember returns
            		TRUE; otherwise, it returns FALSE.
            	</param>
             <returns>
            		If the function succeeds, the return value is nonzero. If the function fails,
            		the return value is zero. To get extended error information, call GetLastError.
             </returns>
        </member>
        <member name="M:Metro.PacketSniffer.FreeSid(System.IntPtr)">
            <summary>
            	The FreeSid function frees a security identifier (SID) previously allocated 
            	by using the AllocateAndInitializeSid function.
            </summary>
            <param name="pSid">
            	Pointer to the SID structure to free.
            </param>
        </member>
        <member name="M:Metro.PacketSniffer.#ctor">
            <summary>
            	Create a new packet sniffer class.
            </summary>
            <exception cref="T:System.NotSupportedException">
            	This program requires administrative privilages on 
            	Windows 2000, Windows XP or Windows .NET Server
            </exception>
        </member>
        <member name="M:Metro.PacketSniffer.StopListening">
            <summary>
            	Stop listening.
            </summary>
        </member>
        <member name="M:Metro.PacketSniffer.StartListening(System.Net.IPEndPoint,Metro.SnifferModeType,System.Net.Sockets.ProtocolType)">
            <summary>
            	Start listening for packets.
            </summary>
            <param name="networkInterface">
            	The network interface to listen on.
            </param>
            <param name="mode">
            	The mode to run in.
            </param>
            <param name="protocol">
            	The protocl to listen for.
            </param>
        </member>
        <member name="M:Metro.PacketSniffer.StartListening(System.Net.IPEndPoint,Metro.SnifferModeType)">
            <summary>
            	Start listening for packets.
            </summary>
            <param name="networkInterface">
            	The network interface to listen on.
            </param>
            <param name="mode">
            	The mode to run in.
            </param>
        </member>
        <member name="M:Metro.PacketSniffer.StartListening(System.Net.IPEndPoint)">
            <summary>
            	Start listening for packets.
            </summary>
            <param name="networkInterface">
            	The network interface to listen on.
            </param>
        </member>
        <member name="M:Metro.PacketSniffer.ReceiveCallback(System.IAsyncResult)">
            <summary>
            	The callback for when a new packet has arrived.
            </summary>
            <param name="ar">
            	Async result.
            </param>
        </member>
        <member name="E:Metro.PacketSniffer.NewPacket">
            <summary>
            	This event is raised whenever a new packet arrives.
            </summary>
        </member>
        <member name="P:Metro.PacketSniffer.IsRunning">
            <summary>
            	Whether or not the sniffer is running.
            </summary>
        </member>
        <member name="P:Metro.PacketSniffer.SnifferMode">
            <summary>
            	The mode to run the sniffer in.
            </summary>
        </member>
        <member name="P:Metro.PacketSniffer.BytesReceived">
            <summary>
            	The number of bytes recieved.
            </summary>
        </member>
        <member name="T:Metro.PacketSniffer.StateObject">
            <summary>
            	The state object,
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.StateObject.BUFFER_SIZE">
            <summary>
            	Buffer size.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.StateObject.m_socketObject">
            <summary>
            	The socket object.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.StateObject.m_recieveBuffer">
            <summary>
            	The recieve buffer.
            </summary>
        </member>
        <member name="F:Metro.PacketSniffer.StateObject.m_waitObject">
            <summary>
            	The wait object.
            </summary>
        </member>
        <member name="P:Metro.PacketSniffer.StateObject.SocketObject">
            <summary>
            	The socket object.
            </summary>
        </member>
        <member name="P:Metro.PacketSniffer.StateObject.RecieveBuffer">
            <summary>
            	The recieve buffer.
            </summary>
        </member>
        <member name="P:Metro.PacketSniffer.StateObject.WaitObject">
            <summary>
            	The wait object.
            </summary>
        </member>
        <member name="T:Metro.PacketUtils">
            <summary>
            	A selection of useful procedures.
            </summary>
        </member>
        <member name="M:Metro.PacketUtils.CalculateChecksum(System.UInt16[],System.Int32)">
            <summary>
            	The checksum field is the 16 bit one's complement of the one's
            	complement sum of all 16 bit words in the header. For purposes of
            	computing the checksum, the value of the checksum field is zero.
            	This method implements this algorithm for computing the checksum
            	in protocols like IP, TCP, UDP, ICMP etc.
            </summary>
            <param name="Buffer">
            	The packet to calculate the checksum for.
            </param>
            <param name="size">
            	The length of the packet.
            </param>
            <returns>
            	The checksum.
            </returns>
        </member>
        <member name="M:Metro.PacketUtils.CalculateChecksum(System.Byte[])">
            <summary>
            	The checksum field is the 16 bit one's complement of the one's
            	complement sum of all 16 bit words in the header. For purposes of
            	computing the checksum, the value of the checksum field is zero.
            	This method implements this algorithm for computing the checksum
            	in protocols like IP, TCP, UDP, ICMP etc.
            </summary>
            <param name="buffer">
            	The packet to calculate the checksum for.
            </param>
            <returns>
            	The checksum.
            </returns>
        </member>
        <member name="T:Metro.Scanning.TcpPortState">
            <summary>
            	The TCP port state.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpPortState.Closed">
            <summary>
            	The port is opened and accepts to connection requests.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpPortState.Opened">
            <summary>
            	The port is closed and rejects connection requests.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpPortState.Filtered">
            <summary>
            	The port is filtered by a firewall of some kind and does not reply
            	to any requests at all.
            </summary>
        </member>
        <member name="T:Metro.Scanning.TcpPortReplyHandler">
            <summary>
            	The handler for an event where a port state is found.
            </summary>
        </member>
        <member name="T:Metro.Scanning.TcpPortScanComplete">
            <summary>
            	The handler for when a port scan is complete.
            </summary>
        </member>
        <member name="T:Metro.Scanning.TcpSynScanner">
            <summary>
            	The TCP SYN scan technique is often referred to as "half-open"
            	scanning, because you don't open a full TCP connection. You send
            	a SYN packet, as if you are going to open a real connection and
            	you wait for a response. A SYN|ACK indicates the port is listening. 
            	A RST is indicative of a non-listener. No response means the port is
            	probably filtered by a router or firewall. If a SYN|ACK is received,  
            	a RST is immediately sent to tear down the connection (actually our 
            	OS kernel does this for us). The primary advantage to this scanning  
            	technique  is  that fewer sites will log it.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_disposed">
            <summary>
            	Stores whether or not this object has been disposed of.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_sniffer">
            <summary>
            	We need a new sniffer to sniff for incoming icmp packets so we can look for the
            	replies.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_localEndPoint">
            <summary>
            	The local interface to use when sending packets.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_remoteEndPoint">
            <summary>
            	The remote end point to send packets to.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_timeoutTimer">
            <summary>
            	The timer used for time out of replies.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_sendTimer">
            <summary>
            	The timer used to time sending of packets so we don't accidentally
            	SYN flood.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_sendInterval">
            <summary>
            	The interval used for the send timer.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_ports">
            <summary>
            	The array of ports to scan.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_portIndex">
            <summary>
            	The current index in the port array.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_waitObject">
            <summary>
            	The wait object is used in blocking mode.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_working">
            <summary>
            	Whether or not the scanner is running.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_incPorts">
            <summary>
            	If set to true, the local port will be incremented each time a new request
            	is sent.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_fragment">
            <summary>
            	If true, packets will be fragmented.
            </summary>
        </member>
        <member name="F:Metro.Scanning.TcpSynScanner.m_socket">
            <summary>
            	The private socket for sending the packets with.
            </summary>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.SendRequest">
            <summary>
            	Send a SYN request to the next port to check it's state.
            </summary>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.SendTimer(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            	The timer event for sending the next packet.
            </summary>
            <param name="source">
            	Source.
            </param>
            <param name="e">
            	Event args.
            </param>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.TimeOut(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            	The timer event for the time out. If this triggers, we assume
            	the port is filtered.
            </summary>
            <param name="source">
            	Source.
            </param>
            <param name="e">
            	Event args.
            </param>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.NewPacket(System.Byte[])">
            <summary>
            	A new packet has arrived.
            </summary>
            <param name="data">
            	The packet.
            </param>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.#ctor(System.Net.IPEndPoint)">
            <summary>
            	Create a new TCP SYN scanner
            </summary>
            <param name="networkInterface">
            	The local network interface to use.
            </param>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.StartScan(System.Net.IPAddress,System.UInt16[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            	Start a new SYN scan. This type of scan is not detected by some sites
            	but most firewalls will easily pick it up. It is also commonly known as a
            	"half open" scan.
            </summary>
            <param name="remoteAddress">
            	The remote address to scan.
            </param>
            <param name="ports">
            	An array of ports to scan.
            </param>
            <param name="timeoutTime">
            	The time to wait before giving up waiting on a reply from a port.
            	If a time out occurs, it is assumed that the port is filtered.
            	A small time out will result in faster scanning, but with less accuracy 
            	on slower connections, where a larger time out will result in more accurate
            	results on slower connections, but will take longer.
            </param>
            <param name="waitTime">
            	The time to wait before sending each request. A very small time is more
            	easily detectable, and may accidentally "SYN flood" the remote host. It will
            	scan faster though. A larger time will be more stealthy, and will not be
            	quite so resource consuming. But it will take longer.
            </param>
            <param name="async">
            	Whether or not to work in async or blocking mode.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
            <exception cref="T:System.Exception">
            		An exception may occur if a scan is already in progress.
            </exception>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.StartScan(System.Net.IPAddress,System.UInt16[],System.Int32,System.Int32)">
            <summary>
            	Start a new SYN scan. This type of scan is not detected by some sites
            	but most firewalls will easily pick it up. It is also commonly known as a
            	"half open" scan.
            </summary>
            <param name="remoteAddress">
            	The remote address to scan.
            </param>
            <param name="ports">
            	An array of ports to scan.
            </param>
            <param name="timeoutTime">
            	The time to wait before giving up waiting on a reply from a port.
            	If a time out occurs, it is assumed that the port is filtered.
            	A small time out will result in faster scanning, but with less accuracy 
            	on slower connections, where a larger time out will result in more accurate
            	results on slower connections, but will take longer.
            </param>
            <param name="waitTime">
            	The time to wait before sending each request. A very small time is more
            	easily detectable, and may accidentally "SYN flood" the remote host. It will
            	scan faster though. A larger time will be more stealthy, and will not be
            	quite so resource consuming. But it will take longer.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
            <exception cref="T:System.Exception">
            		An exception may occur if a scan is already in progress.
            </exception>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.StartScan(System.Net.IPAddress,System.UInt16[])">
            <summary>
            	Start a new SYN scan. This type of scan is not detected by some sites
            	but most firewalls will easily pick it up. It is also commonly known as a
            	"half open" scan.
            </summary>
            <param name="remoteAddress">
            	The remote address to scan.
            </param>
            <param name="ports">
            	An array of ports to scan.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
            <exception cref="T:System.Exception">
            		An exception may occur if a scan is already in progress.
            </exception>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.CancelScan">
            <summary>
            	Cancel a running port scan.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.Dispose">
            <summary>
            	Dispose.
            </summary>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.Dispose(System.Boolean)">
            <summary>
            	Dispose.
            </summary>
            <param name="disposing">
            	If disposing equals true, the method has been called directly
            	or indirectly by a user's code. Managed and unmanaged resources
            	can be disposed.
            	If disposing equals false, the method has been called by the 
            	runtime from inside the finalizer and you should not reference 
            	other objects. Only unmanaged resources can be disposed.
            </param>
        </member>
        <member name="M:Metro.Scanning.TcpSynScanner.Finalize">
            <summary>
            	Destructor.
            </summary>
        </member>
        <member name="E:Metro.Scanning.TcpSynScanner.PortReply">
            <summary>
            	This event occurs when a ports status has been going.
            </summary>
        </member>
        <member name="E:Metro.Scanning.TcpSynScanner.ScanComplete">
            <summary>
            	This event is raised when te trace is complete.
            </summary>
        </member>
        <member name="P:Metro.Scanning.TcpSynScanner.Running">
            <summary>
            	Whether or not a scan is currently running.
            </summary>
        </member>
        <member name="P:Metro.Scanning.TcpSynScanner.TimeOutInterval">
            <summary>
            	The time out time.
            </summary>
        </member>
        <member name="P:Metro.Scanning.TcpSynScanner.SendInterval">
            <summary>
            	The time to wait before sending each request. A very small time is more
            	easily detectable, and may accidentally "SYN flood" the remote host. It will
            	scan faster though. A larger time will be more stealthy, and will not be
            	quite so resource consuming. But it will take longer.
            </summary>
        </member>
        <member name="P:Metro.Scanning.TcpSynScanner.IncrementLocalPorts">
            <summary>
            	If true, the local port numbers will be incremented for each packet sent.
            </summary>
        </member>
        <member name="P:Metro.Scanning.TcpSynScanner.FragmentPackets">
            <summary>
            	If true, IP packets will be fragmented.
            </summary>
        </member>
        <member name="P:Metro.Scanning.TcpSynScanner.Disposed">
            <summary>
            	Whether or not the class has been disposed.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpGenericError">
            <summary>
            	Icmp messages which consist of some kind of error where the IP header and
            	the first 64 bits of data are placed after the unused field can inherit
            	from this class.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpGenericError.m_badPacket">
            <summary>
            	The IP header and the first 64 bits of data from the originating
            	packet which caused the ICMP message.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpGenericError.Constructor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new generic error ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpGenericError.Serialize">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpGenericError.BadPacket">
            <summary>
            	The IP header and the first 64 bits of data from the originating
            	packet which caused the ICMP message.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable">
             <summary>
            		If, according to the information in the gateway's routing tables,
            		the network specified in the internet destination field of a
            		datagram is unreachable, e.g., the distance to the network is
            		infinity, the gateway may send a destination unreachable message
            		to the internet source host of the datagram. In addition, in some
            		networks, the gateway may be able to determine if the internet
            		destination host is unreachable. Gateways in these networks may
            		send destination unreachable messages to the source host when the
            		destination host is unreachable.
            
            		If, in the destination host, the IP module cannot deliver the
            		datagram  because the indicated protocol module or process port is
            		not active, the destination host may send a destination
            		unreachable message to the source host.
            
            		Another case is when a datagram must be fragmented to be forwarded
            		by a gateway yet the Don't Fragment flag is on. In this case the
            		gateway must discard the datagram and may return a destination
            		unreachable message.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.m_code">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.#ctor">
            <summary>
            	Create a new destination unreachable ICMP packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.#ctor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new destination unreachable ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The packet was not a Destination Unreachable type packet.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.Serialize">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.Code">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType.NetUnreachable">
            <summary>
            	Net unreachable.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType.HostUnreachable">
            <summary>
            	Host unreachable.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType.ProtocolUnreachable">
            <summary>
            	Protocol unreachable.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType.PortUnreachable">
            <summary>
            	Port unreachable.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType.FragmentationNeeded">
            <summary>
            	Fragmentation is required but the Don't Fragment (DF) bit is set.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpDestinationUnreachable.CodeType.SourceRouteFailed">
            <summary>
            	Source route failed.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpTimeExceeded">
             <summary>
            		If the gateway processing a datagram finds the time to live field
            		is zero it must discard the datagram. The gateway may also notify
            		the source host via the time exceeded message.
            
            		If a host reassembling a fragmented datagram cannot complete the
            		reassembly due to missing fragments within its time limit it
            		discards the datagram, and it may send a time exceeded message.
            
            		If fragment zero is not available then no time exceeded need be
            		sent at all.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTimeExceeded.m_code">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTimeExceeded.#ctor">
            <summary>
            	Create a new time exceeded ICMP packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTimeExceeded.#ctor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new time exceeded ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The packet was not a Time Exceeded type packet.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTimeExceeded.Serialize">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTimeExceeded.Code">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpTimeExceeded.CodeType">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTimeExceeded.CodeType.TtlExceeded">
            <summary>
            	Time to live exceeded in transit;
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTimeExceeded.CodeType.ReassemblyTimeExceeded">
            <summary>
            	Fragment reassembly time exceeded.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpParameterProblem">
            <summary>
            	If the gateway or host processing a datagram finds a problem with
            	the header parameters such that it cannot complete processing the
            	datagram it must discard the datagram. One potential source of
            	such a problem is with incorrect arguments in an option. The
            	gateway or host may also notify the source host via the parameter
            	problem message. This message is only sent if the error caused
            	the datagram to be discarded.
            </summary>	
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpParameterProblem.m_pointer">
            <summary>
            	Identifies the octet where an error was detected.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpParameterProblem.#ctor">
            <summary>
            	Create a new parameter problem ICMP packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpParameterProblem.#ctor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new parameter problem ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The packet was not a Parameter Problem type packet.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpParameterProblem.Serialize">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpParameterProblem.ErrorPointer">
            <summary>
            	Identifies the octet where an error was detected.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpSourceQuench">
             <summary>
            		A gateway may discard internet datagrams if it does not have the
            		buffer space needed to queue the datagrams for output to the next
            		network on the route to the destination network. If a gateway
            		discards a datagram, it may send a source quench message to the
            		internet source host of the datagram. A destination host may also
            		send a source quench message if datagrams arrive too fast to be
            		processed. The source quench message is a request to the host to
            		cut back the rate at which it is sending traffic to the internet
            		destination. The gateway may send a source quench message for
            		every message that it discards. On receipt of a source quench
            		message, the source host should cut back the rate at which it is
            		sending traffic to the specified destination until it no longer
            		receives source quench messages from the gateway. The source host
            		can then gradually increase the rate at which it sends traffic to
            		the destination until it again receives source quench messages.
            
            		The gateway or host may send the source quench message when it
            		approaches its capacity limit rather than waiting until the
            		capacity is exceeded. This means that the data datagram which
            		triggered the source quench message may be delivered.
             </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpSourceQuench.#ctor">
            <summary>
            	Create a new source quench ICMP packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpSourceQuench.#ctor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new source quench ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The packet was not a Source Quench type packet.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpSourceQuench.Serialize">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpRedirect">
             <summary>
            		The gateway sends a redirect message to a host in the following
            		situation. A gateway, G1, receives an internet datagram from a
            		host on a network to which the gateway is attached. The gateway,
            		G1, checks its routing table and obtains the address of the next
            		gateway, G2, on the route to the datagram's internet destination
            		network, X.  If G2 and the host identified by the internet source
            		address of the datagram are on the same network, a redirect
            		message is sent to the host. The redirect message advises the
            		host to send its traffic for network X directly to gateway G2 as
            		this is a shorter path to the destination. The gateway forwards
            		the original datagram's data to its internet destination.
            
            		For datagrams with the IP source route options and the gateway
            		address in the destination address field, a redirect message is
            		not sent even if there is a better route to the ultimate
            		destination than the next address in the source route.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpRedirect.m_code">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpRedirect.m_gatewayAddress">
            <summary>
            	Address of the gateway to which traffic for the network specified
            	in the internet destination network field of the original
            	datagram's data should be sent.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpRedirect.#ctor">
            <summary>
            	Create a new redirect ICMP packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpRedirect.#ctor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new redirect ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The packet was not a Redirect type packet.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpRedirect.Serialize">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpRedirect.Code">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpRedirect.GatewayAddress">
            <summary>
            	Address of the gateway to which traffic for the network specified
            	in the internet destination network field of the original
            	datagram's data should be sent.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpRedirect.CodeType">
            <summary>
            	The code type.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpRedirect.CodeType.RedirectForNetwork">
            <summary>
            	Redirect datagrams for the Network.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpRedirect.CodeType.RedirectForHost">
            <summary>
            	Redirect datagrams for the Host.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpRedirect.CodeType.RedirectForTOSAndNetwork">
            <summary>
            	Redirect datagrams for the Type of Service and Network.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpRedirect.CodeType.RedirectForTOSAndHost">
            <summary>
            	Redirect datagrams for the Type of Service and Host.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpEcho">
            <summary>
            	The data received in the echo message must be returned in the echo
            	reply message.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpEcho.m_random">
            <summary>
            	Used for generating random numbers
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpEcho.m_identifier">
            <summary>
            	An identifier to aid in matching echos and replies, may be zero.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpEcho.m_sequenceNumber">
            <summary>
            	A sequence number to aid in matching echos and replies, may be zero.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpEcho.m_data">
            <summary>
            	The data received in the echo message must be returned in the echo
            	reply message.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpEcho.#ctor">
            <summary>
            	Create a new echo ICMP packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpEcho.#ctor(Metro.TransportLayer.Icmp.IcmpPacket)">
            <summary>
            	Create a new echo ICMP packet.
            </summary>
            <param name="packet">
            	The ICMP packet to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	If the packet is null then an argument null exception occurs.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The packet was not a Echo packet.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpEcho.Serialize(System.Boolean)">
            <summary>
            	Serlialize this icmp message into an IcmpPacket which can
            	then be serialized further.
            </summary>
            <param name="reply">
            	If true, this packet is an echo reply, otherwise it is an echo request.
            </param>
            <returns>	
            	An IcmpPacket class.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpEcho.Identifier">
            <summary>
            	An identifier to aid in matching echos and replies, may be zero.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpEcho.SequenceNumber">
            <summary>
            	A sequence number to aid in matching echos and replies, may be zero.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpEcho.Data">
            <summary>
            	The data received in the echo message must be returned in the echo
            	reply message.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpTimeStamp">
             <summary>
            		The data received (a timestamp) in the message is returned in the
            		reply together with an additional timestamp. The timestamp is 32
            		bits of milliseconds since midnight UT.
            
            		The Originate Timestamp is the time the sender last touched the
            		message before sending it, the Receive Timestamp is the time the
            		echoer first touched it on receipt, and the Transmit Timestamp is
            		the time the echoer last touched the message on sending it.
            
            		If the time is not available in miliseconds or cannot be provided
            		with respect to midnight UT then any time can be inserted in a
            		timestamp provided the high order bit of the timestamp is also set
            		to indicate this non-standard value.
             </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpPacketArrivedHandler">
            <summary>
            	The handler for when a new packet has arrived.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpMessageType">
            <summary>
            	The type of message.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.EchoReply">
            <summary>
            	The data received in the echo message must be returned in the echo
            	reply message.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.DestinationUnreachable">
             <summary>
            		If, according to the information in the gateway's routing tables,
            		the network specified in the internet destination field of a
            		datagram is unreachable, e.g., the distance to the network is
            		infinity, the gateway may send a destination unreachable message
            		to the internet source host of the datagram. In addition, in some
            		networks, the gateway may be able to determine if the internet
            		destination host is unreachable. Gateways in these networks may
            		send destination unreachable messages to the source host when the
            		destination host is unreachable.
            
            		If, in the destination host, the IP module cannot deliver the
            		datagram  because the indicated protocol module or process port is
            		not active, the destination host may send a destination
            		unreachable message to the source host.
            
            		Another case is when a datagram must be fragmented to be forwarded
            		by a gateway yet the Don't Fragment flag is on. In this case the
            		gateway must discard the datagram and may return a destination
            		unreachable message.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.SourceQuench">
             <summary>
            		A gateway may discard internet datagrams if it does not have the
            		buffer space needed to queue the datagrams for output to the next
            		network on the route to the destination network. If a gateway
            		discards a datagram, it may send a source quench message to the
            		internet source host of the datagram. A destination host may also
            		send a source quench message if datagrams arrive too fast to be
            		processed. The source quench message is a request to the host to
            		cut back the rate at which it is sending traffic to the internet
            		destination. The gateway may send a source quench message for
            		every message that it discards. On receipt of a source quench
            		message, the source host should cut back the rate at which it is
            		sending traffic to the specified destination until it no longer
            		receives source quench messages from the gateway. The source host
            		can then gradually increase the rate at which it sends traffic to
            		the destination until it again receives source quench messages.
            
            		The gateway or host may send the source quench message when it
            		approaches its capacity limit rather than waiting until the
            		capacity is exceeded. This means that the data datagram which
            		triggered the source quench message may be delivered.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.Redirect">
             <summary>
            		The gateway sends a redirect message to a host in the following
            		situation. A gateway, G1, receives an internet datagram from a
            		host on a network to which the gateway is attached. The gateway,
            		G1, checks its routing table and obtains the address of the next
            		gateway, G2, on the route to the datagram's internet destination
            		network, X.  If G2 and the host identified by the internet source
            		address of the datagram are on the same network, a redirect
            		message is sent to the host. The redirect message advises the
            		host to send its traffic for network X directly to gateway G2 as
            		this is a shorter path to the destination. The gateway forwards
            		the original datagram's data to its internet destination.
            
            		For datagrams with the IP source route options and the gateway
            		address in the destination address field, a redirect message is
            		not sent even if there is a better route to the ultimate
            		destination than the next address in the source route.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.Echo">
            <summary>
            	The data received in the echo message must be returned in the echo
            	reply message.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.TimeExceeded">
             <summary>
            		If the gateway processing a datagram finds the time to live field
            		is zero it must discard the datagram. The gateway may also notify
            		the source host via the time exceeded message.
            
            		If a host reassembling a fragmented datagram cannot complete the
            		reassembly due to missing fragments within its time limit it
            		discards the datagram, and it may send a time exceeded message.
            
            		If fragment zero is not available then no time exceeded need be
            		sent at all.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.ParameterProblem">
            <summary>
            	If the gateway or host processing a datagram finds a problem with
            	the header parameters such that it cannot complete processing the
            	datagram it must discard the datagram. One potential source of
            	such a problem is with incorrect arguments in an option. The
            	gateway or host may also notify the source host via the parameter
            	problem message. This message is only sent if the error caused
            	the datagram to be discarded.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.TimeStamp">
             <summary>
            		The data received (a timestamp) in the message is returned in the
            		reply together with an additional timestamp. The timestamp is 32
            		bits of milliseconds since midnight UT.
            
            		The Originate Timestamp is the time the sender last touched the
            		message before sending it, the Receive Timestamp is the time the
            		echoer first touched it on receipt, and the Transmit Timestamp is
            		the time the echoer last touched the message on sending it.
            
            		If the time is not available in miliseconds or cannot be provided
            		with respect to midnight UT then any time can be inserted in a
            		timestamp provided the high order bit of the timestamp is also set
            		to indicate this non-standard value.
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpMessageType.TimestampReply">
             <summary>
            		The data received (a timestamp) in the message is returned in the
            		reply together with an additional timestamp. The timestamp is 32
            		bits of milliseconds since midnight UT.
            
            		The Originate Timestamp is the time the sender last touched the
            		message before sending it, the Receive Timestamp is the time the
            		echoer first touched it on receipt, and the Transmit Timestamp is
            		the time the echoer last touched the message on sending it.
            
            		If the time is not available in miliseconds or cannot be provided
            		with respect to midnight UT then any time can be inserted in a
            		timestamp provided the high order bit of the timestamp is also set
            		to indicate this non-standard value.
             </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpPacket">
             <summary>
            		Occasionally a gateway or destination host will communicate with a source host, 
            		for example, to report an error in datagram processing. For such purposes this 
            		protocol, the Internet Control Message Protocol (ICMP), is used. ICMP, uses 
            		the basic support of IP as if it were a higher level protocol, however, 
            		ICMP is actually an integral part of IP, and must be implemented by every IP 
            		module.
            
            		ICMP messages are sent in several situations: for example, when a datagram 
            		cannot reach its destination, when the gateway does not have the buffering 
            		capacity to forward a datagram, and when the gateway can direct the host to send 
            		traffic on a shorter route.
            
            		The ICMP messages typically report errors in the processing of datagrams.  
            		To avoid the infinite regress of messages about messages etc., no ICMP messages 
            		are sent about ICMP messages. Also ICMP messages are only sent about errors in 
            		handling fragment zero of fragemented datagrams. (Fragment zero has the fragment 
            		offeset equal zero).
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPacket.m_type">
            <summary>
            	The type of message being sent. This should be enumerated and the data passed
            	to the correct class to be parsed.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPacket.m_code">
            <summary>
            	The meaning of the code field is dependant on the type of message. Codes are
            	given a meaning once passed to the correct icmp class.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPacket.m_checksum">
            <summary>
            	The checksum is the 16-bit ones's complement of the one's
            	complement sum of the ICMP message starting with the ICMP Type.
            	For computing the checksum, the checksum field should be zero.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPacket.m_data">
            <summary>
            	The rest of the ICMP packet. This data is parsed further onces
            	passed to the specific ICMP class.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPacket.#ctor">
            <summary>
            	Create a new Icmp packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPacket.#ctor(System.Byte[])">
            <summary>
            	Create a new Icmp packet.
            </summary>
            <param name="data">
            	The byte array representing the Icmp packet.
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPacket.Serialize">
            <summary>
            	This method will calculate the checksum then pack the fields into a byte array 
            	in the format of an icmp header. This can then be attached to a network 
            	layer protocol and then transmitted over the internet.
            </summary>
            <returns>
            	The return value is a byte array with the Icmp header at the beginning which can be
            	appended to a network layer protocol such as IP. 
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpPacket.MessageType">
            <summary>
            	The type of message being sent. This should be enumerated and the data passed
            	to the correct class to be parsed.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpPacket.Code">
            <summary>
            	The meaning of the code field is dependant on the type of message. Codes are
            	given a meaning once passed to the correct icmp class.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpPacket.Checksum">
            <summary>
            	The checksum is the 16-bit ones's complement of the one's
            	complement sum of the ICMP message starting with the ICMP Type.
            	For computing the checksum, the checksum field should be zero.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpPacket.Data">
            <summary>
            	The rest of the ICMP packet. This data is parsed further onces
            	passed to the specific ICMP class.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpPingReplyHandler">
            <summary>
            	The handler for when a new ping has arrived.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpPingTimeOutHandler">
            <summary>
            	The handler for when a ping request times out.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpPingManager">
            <summary>
            	This class will handle sending and recieving of
            	a single ping packet, including matching up the correct reply and calculating
            	the round trip time.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_disposed">
            <summary>
            	Stores whether or not this object has been disposed of.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_sniffer">
            <summary>
            	We need a new sniffer to sniff for incoming icmp packets so we can look for the
            	replies.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_id">
            <summary>
            	The identification of the current ping packet is stored so we can match its
            	reply.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_remoteAddress">
            <summary>
            	The remote address of the current ping packet is stores so that we can match
            	its reply.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_waitObject">
            <summary>
            	The wait object is used in blocking mode to stop the SendPing method
            	from returning until the reply has been recieved.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_start">
            <summary>
            	The time we sent the packet.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_stop">
            <summary>
            	The time we recieved the reply.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_timer">
            <summary>
            	Create a new timer used for timeouts.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_networkInterface">
            <summary>
            	The local interface to bind to.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_fragment">
            <summary>
            	Whether or not to fragment IP packets.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpPingManager.m_socket">
            <summary>
            	The private socket for sending the packets with.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.NewPacket(System.Byte[])">
            <summary>
            
            </summary>
            <param name="data">
            
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.TimeOut(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            	Occurs when the ping timed out
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.#ctor(System.Net.IPAddress)">
            <summary>
            	Create a new ping manager. This class will handle sending and recieving of
            	a single ping packet, including matching up the correct reply and calculating
            	the round trip time.
            </summary>
            <param name="networkInterface">
            	The interface to send the ping packet on.
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.SendPing(System.Net.IPAddress,System.Byte[],System.Boolean,System.Double)">
            <summary>
            	Send a new ping packet.
            </summary>
            <param name="destination">
            	The address to send the packet to.
            </param>	
            <param name="payload">
            	The data to send in the ping.
            </param>
            <param name="async">
            	If this is true, SendPing will return immediately otherwise it will wait
            </param>
            <param name="timeOutTime">
            	The number of milliseconds before the reply times out.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	If the class has been disposed then an ObjectDisposedException will be thrown.
            </exception>
            <exception cref="T:System.Exception">
            	If the class is already waiting for a ping reply then an exception will be thrown.
            	Use the CancelPing method first.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.SendPing(System.Net.IPAddress,System.Byte[],System.Boolean)">
            <summary>
            	Send a new ping packet.
            </summary>
            <param name="destination">
            	The address to send the packet to.
            </param>	
            <param name="payload">
            	The data to send in the ping.
            </param>
            <param name="async">
            	If this is true, SendPing will return immediately otherwise it will wait
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	If the class has been disposed then an ObjectDisposedException will be thrown.
            </exception>
            <exception cref="T:System.Exception">
            	If the class is already waiting for a ping reply then an exception will be thrown.
            	Use the CancelPing method first.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.SendPing(System.Net.IPAddress,System.Byte[])">
            <summary>
            	Send a new ping packet.
            </summary>
            <param name="destination">
            	The address to send the packet to.
            </param>	
            <param name="payload">
            	The data to send in the ping.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	If the class has been disposed then an ObjectDisposedException will be thrown.
            </exception>
            <exception cref="T:System.Exception">
            	If the class is already waiting for a ping reply then an exception will be thrown.
            	Use the CancelPing method first.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.SendPing(System.Net.IPAddress,System.Int32)">
            <summary>
            	Send a new ping packet.
            </summary>
            <param name="destination">
            	The address to send the packet to.
            </param>	
            <param name="payloadSize">
            	The size of the payload.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	If the class has been disposed then an ObjectDisposedException will be thrown.
            </exception>
            <exception cref="T:System.Exception">
            	If the class is already waiting for a ping reply then an exception will be thrown.
            	Use the CancelPing method first.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.SendPing(System.Net.IPAddress)">
            <summary>
            	Send a new ping packet.
            </summary>
            <param name="destination">
            	The address to send the packet to.
            </param>	
            <exception cref="T:System.ObjectDisposedException">
            	If the class has been disposed then an ObjectDisposedException will be thrown.
            </exception>
            <exception cref="T:System.Exception">
            	If the class is already waiting for a ping reply then an exception will be thrown.
            	Use the CancelPing method first.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.CancelPing">
            <summary>
            	Cancel a ping request.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpPingManager.Dispose">
            <summary>
            	Dispose of this class.
            </summary>
        </member>
        <member name="E:Metro.TransportLayer.Icmp.IcmpPingManager.PingReply">
            <summary>
            	When the ping reply has been recieved, this event is raised.
            </summary>
        </member>
        <member name="E:Metro.TransportLayer.Icmp.IcmpPingManager.PingTimeout">
            <summary>
            	When a ping request times out, this event is raised.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpPingManager.FragmentPackets">
            <summary>
            	Whether or not to fragment IP packets.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.RouteUpdateHandler">
            <summary>
            	The handler for a route update event.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.MaxHopsExceededHandler">
            <summary>
            	The handler for the hops exceeded event.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.TraceFinishedHandler">
            <summary>
            	The handler for the trace finished event.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Icmp.IcmpTraceRoute">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_disposed">
            <summary>
            	Stores whether or not this object has been disposed of.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_sniffer">
            <summary>
            	We need a new sniffer to sniff for incoming icmp packets so we can look for the
            	replies.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_id">
            <summary>
            	The identification of the current ping packet is stored so we can match its
            	reply.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_ipId">
            <summary>
            	Ip identification.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_remoteAddress">
            <summary>
            	The remote address of the current ping packet is stores so that we can match
            	its reply.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_localAddress">
            <summary>
            	The local network interface.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_waitObject">
            <summary>
            	The wait object is used in blocking mode to stop the SendPing method
            	from returning until the reply has been recieved.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_start">
            <summary>
            	The time we sent the packet.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_stop">
            <summary>
            	The time we recieved the reply.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_ttl">
            <summary>
            	Store the time to live.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_maxHops">
            <summary>
            	The maximum number of hops.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_timeoutTime">
            <summary>
            	The number of milliseconds that must pass before
            	a request times out.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_timer">
            <summary>
            	Create a new timer used for timeouts.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_working">
            <summary>
            	Whether or not the trace is running.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_fragment">
            <summary>
            	Whether or not to fragment IP packets.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_route">
            <summary>
            	The route to take.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_strictRouting">
            <summary>
            	If strict rource routing is turned on the the exact route specified
            	will be taken.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Icmp.IcmpTraceRoute.m_socket">
            <summary>
            	The private socket for sending the packets with.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.SendRequest">
            <summary>
            	Send the next request in order to find the next hop.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.NewPacket(System.Byte[])">
            <summary>
            	This event occurs whenever a new packet arrives.
            </summary>
            <param name="data">
            	The data in the packet.
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.TimeOut(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            	Occurs when the ping timed out
            </summary>
            <param name="source">
            
            </param>
            <param name="e">
            
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.#ctor(System.Net.IPAddress)">
            <summary>
            	Create a new IcmpTraceRoute class for performing route traces to hosts using
            	ICMP ping packets.
            </summary>
            <param name="networkInterface">
            	The local network interface to use.
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.TraceRoute(System.Net.IPAddress,System.Boolean,System.Int32,System.Byte)">
            <summary>
            	Perform a new route trace.
            </summary>
            <param name="destination">
            	The remote host to trace the route to.
            </param>
            <param name="async">
            	Whether or not to use blocking mode. If this is true then the
            	method will not block.
            </param>
            <param name="timeOutTime">
            	Time time out time.
            </param>
            <param name="maxHops">
            	The maximum number of hops.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
            <exception cref="T:System.Exception">
            		An exception may occur if a trace is already in progress.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.TraceRoute(System.Net.IPAddress)">
            <summary>
            	Perform a new route trace.
            </summary>
            <param name="destination">
            	The remote host to trace the route to.
            </param>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
            <exception cref="T:System.Exception">
            		An exception may occur if a trace is already in progress.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.CancelTrace">
            <summary>
            	Cancel a current trace.
            </summary>
            <exception cref="T:System.ObjectDisposedException">
            	An ObjectDisposedException will occur if this class has already been disposed. 
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Icmp.IcmpTraceRoute.Dispose">
            <summary>
            	Dispose of this class.
            </summary>
        </member>
        <member name="E:Metro.TransportLayer.Icmp.IcmpTraceRoute.RouteUpdate">
            <summary>
            	This event occurs whenever the next hop is found.
            </summary>
        </member>
        <member name="E:Metro.TransportLayer.Icmp.IcmpTraceRoute.MaxHopsExceeded">
            <summary>
            	This event occurs when the mex hop count is reached.
            </summary>
        </member>
        <member name="E:Metro.TransportLayer.Icmp.IcmpTraceRoute.TraceFinished">
            <summary>
            	This event occurs when the trace is complete.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTraceRoute.Running">
            <summary>
            	Whether or not a trace is currently running.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTraceRoute.TimeOutInterval">
            <summary>
            	The time out time.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTraceRoute.MaxHops">
            <summary>
            	The maximum number of hops.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTraceRoute.FragmentPackets">
            <summary>
            	Whether or not to fragment IP packets.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTraceRoute.UseStrictRouting">
            <summary>
            	If strict rource routing is turned on the the exact route specified
            	will be taken.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Icmp.IcmpTraceRoute.Route">
            <summary>
            	The route to take.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpState">
            <summary>
            	A connection progresses through a series of states during its
            	lifetime. The states are: LISTEN, SYN-SENT, SYN-RECEIVED,
            	ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK,
            	TIME-WAIT, and the fictional state CLOSED. CLOSED is fictional
            	because it represents the state when there is no TCB, and therefore,
            	no connection.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.Closed">
            <summary>
            	Represents no connection state at all.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.Listen">
            <summary>
            	Represents waiting for a connection request from any remote TCP 
            	and port.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.SynSent">
            <summary>
            	Represents waiting for a matching connection request after having 
            	sent a connection request.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.SynRecieved">
            <summary>
            	Represents waiting for a confirming connection equest acknowledgment 
            	after having both received and sent a connection request.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.Established">
            <summary>
            	Represents an open connection, data received can be delivered to the 
            	user. The normal state for the data transfer phase of the connection.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.FinWait1">
            <summary>
            	Represents waiting for a connection termination request from the remote 
            	TCP, or an acknowledgment of the connection termination request previously 
            	sent.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.FinWait2">
            <summary>
            	Represents waiting for a connection termination request from the remote TCP.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.CloseWait">
            <summary>
            	Represents waiting for a connection termination request from the local user.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.Closing">
            <summary>
            	Represents waiting for a connection termination request acknowledgment 
            	from the remote TCP.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.LastAck">
            <summary>
            	Represents waiting for an acknowledgment of the connection termination 
            	request previously sent to the remote TCP (which includes an acknowledgment 
            	of its connection termination request).
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.TimeWait">
            <summary>
            	Represents waiting for enough time to pass to be sure the remote TCP 
            	received the acknowledgment of its connection termination request.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpState.DeleteTcb">
            <summary>
            	Delete TCB
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpConnection">
            <summary>
            
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpConnection.m_localEndPoint">
            <summary>
            	The local end point.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpConnection.m_remoteEndPoint">
            <summary>
            	The remote end point.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpConnection.m_state">
            <summary>
            	The connection state.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpConnection.LocalEndPoint">
            <summary>
            	The local end point.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpConnection.RemoteEndPoint">
            <summary>
            	The remote end point.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpConnection.State">
            <summary>
            	The connection state.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpConnectionManager">
            <summary>
            	The TcpConnectionManager class allows the TCP connection table to be read.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpConnectionManager.GetTcpTable(System.Byte[],System.Int32@,System.Boolean)">
            <summary>
            	Read the TCP table.
            </summary>
            <param name="pTcpTable">
            	The buffer to store the table in.
            </param>
            <param name="pdwSize">
            	The size of the table in bytes.
            </param>
            <param name="bOrder">	
            	Whether or not to order the table.
            </param>
            <returns>
            	Return value.
            </returns>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpConnectionManager.GetCurrentTcpConnections">
            <summary>
            	Retrieves the current table of tcp connections.
            </summary>
            <returns>
            	An array of tcp connection entries representing the
            	tcp table.
            </returns>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpMaxSegmentSizeOption">
            <summary>
            	If this option is present, then it communicates the maximum
            	receive segment size at the TCP which sends this segment.
            	This field must only be sent in the initial connection request
            	(i.e., in segments with the SYN control bit set). If this
            	option is not used, any segment size is allowed.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpMaxSegmentSizeOption.m_maxSegmentSize">
            <summary>
            	If this option is present, then it communicates the maximum
            	receive segment size at the TCP which sends this segment.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpMaxSegmentSizeOption.#ctor">
            <summary>
            	Create a new max segment size option.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpMaxSegmentSizeOption.#ctor(Metro.TransportLayer.Tcp.TcpOption)">
            <summary>
            	Create a new max segment size option.
            </summary>
            <param name="option">
            	The option to parse.
            </param>
            <exception cref="T:System.ArgumentNullException">
            	The option argument is null.
            </exception>
            <exception cref="T:System.ArgumentException">
            	The option argument is not a max segment size option.
            </exception>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpMaxSegmentSizeOption.Serialize">
            <summary>
            	Serlialize this routing option into something which
            	can be passed to a TcpPacket class.
            </summary>
            <returns>	
            	An InternetProtocolOption class which can be passed to an IpV4Packet.
            </returns>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpMaxSegmentSizeOption.MaxSegmentSize">
            <summary>
            	If this option is present, then it communicates the maximum
            	receive segment size at the TCP which sends this segment.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpPacketArrivedHandler">
            <summary>
            	The handler for when a new packet has arrived.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpFlags">
            <summary>
            	Control bits.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpFlags.Finish">
            <summary>
            	FIN: No more data from sender.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpFlags.Synchronize">
            <summary>
            	SYN: Synchronize sequence numbers.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpFlags.Reset">
            <summary>
            	RST: Reset the connection.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpFlags.Push">
            <summary>
            	PSH: Push Function.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpFlags.Acknowledgment">
            <summary>
            	ACK: Acknowledgment field significant.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpFlags.Urgent">
            <summary>
            	URG: Urgent Pointer field significant.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpOptionNumber">
            <summary>
            	The type of option.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpOptionNumber.EndOfOptions">
            <summary>
            	End of option list.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpOptionNumber.NoOperation">
            <summary>
            	No operation.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpOptionNumber.MaximumSegmentSize">
            <summary>
            	Maximum segment size.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpOption">
            <summary>
            	The options may appear or not in datagrams.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpOption.m_number">
            <summary>
            	The option type.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpOption.m_length">
            <summary>
            	The length of the option including the option type field and the
            	length field.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpOption.m_data">
            <summary>
            	The data stored in the option. This is parsed by specific option
            	classes
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpOption.OptionType">
            <summary>
            	The option type.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpOption.Length">
            <summary>
            	The length of the option including the option type field and the
            	length field.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpOption.Data">
            <summary>
            	The data stored in the option. This is parsed by specific option
            	classes.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Tcp.TcpPacket">
            <summary>
            	TCP is a connection-oriented, end-to-end reliable protocol designed to
            	fit into a layered hierarchy of protocols which support multi-network
            	applications. The TCP provides for reliable inter-process
            	communication between pairs of processes in host computers attached to
            	distinct but interconnected computer communication networks. Very few
            	assumptions are made as to the reliability of the communication
            	protocols below the TCP layer. TCP assumes it can obtain a simple,
            	potentially unreliable datagram service from the lower level
            	protocols. In principle, the TCP should be able to operate above a
            	wide spectrum of communication systems ranging from hard-wired
            	connections to packet-switched or circuit-switched networks.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_random">
            <summary>
            	Used for generating random numbers.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_sourcePort">
            <summary>
            	The source port number.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_destPort">
            <summary>
            	The destination port number.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_sequenceNumber">
            <summary>
            	The sequence number of the first data octet in this segment (except
            	when SYN is present). If SYN is present the sequence number is the
            	initial sequence number (ISN) and the first data octet is ISN+1.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_acknowledgmentNumber">
            <summary>
            	If the ACK control bit is set this field contains the value of the
            	next sequence number the sender of the segment is expecting to
            	receive. Once a connection is established this is always sent.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_offset">
            <summary>
            	This indicates where the data begins.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_flags">
            <summary>
            	Control bits.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_window">
            <summary>
            	The number of data octets beginning with the one indicated in the
            	acknowledgment field which the sender of this segment is willing to
            	accept.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_checksum">
            <summary>
            	The checksum field is the 16 bit one's complement of the one's
            	complement sum of all 16 bit words in the header and text. If a
            	segment contains an odd number of header and text octets to be
            	checksummed, the last octet is padded on the right with zeros to
            	form a 16 bit word for checksum purposes. The pad is not
            	transmitted as part of the segment.  While computing the checksum,
            	the checksum field itself is replaced with zeros.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_urgentPointer">
            <summary>
            	This field communicates the current value of the urgent pointer as a
            	positive offset from the sequence number in this segment.  The
            	urgent pointer points to the sequence number of the octet following
            	the urgent data.  This field is only be interpreted in segments with
            	the URG control bit set.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_options">
            <summary>
            	Options may occupy space at the end of the TCP header and are a
            	multiple of 8 bits in length. All options are included in the
            	checksum. An option may begin on any octet boundary.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_padding">
            <summary>
            	The TCP header padding is used to ensure that the TCP header ends
            	and data begins on a 32 bit boundary. The padding is composed of
            	zeros.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Tcp.TcpPacket.m_data">
            <summary>
            	The data.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpPacket.#ctor">
            <summary>
            	Create a new Tcp packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpPacket.#ctor(System.Byte[])">
            <summary>
            	Create a new Tcp packet.
            </summary>
            <param name="data">
            	The byte array representing the Tcp packet.
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpPacket.Serialize(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            	This method will calculate several fields such as the checksum then pack the fields 
            	into a byte array in the format of a tcp header. This can then be attached to a 
            	network layer protocol and then transmitted over the internet.
            </summary>
            <returns>
            	The return value is a byte array with the tcp header at the beginning which can be
            	appended to a network layer protocol such as IP. 
            </returns>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpPacket.IsFlagSet(Metro.TransportLayer.Tcp.TcpFlags)">
            <summary>
            	Check whether or not a certain TCP flag is set.
            </summary>
            <param name="flag">
            	The flag to check.
            </param>
            <returns>
            	Returns true if the flag is set, false otherwise.
            </returns>
        </member>
        <member name="M:Metro.TransportLayer.Tcp.TcpPacket.SetFlag(Metro.TransportLayer.Tcp.TcpFlags,System.Boolean)">
            <summary>
            	Set or unset a particular flag.
            </summary>
            <param name="flag">
            	The flag to set or unset.
            </param>
            <param name="flagValue">
            	true to set, false to unset.
            </param>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.SourcePort">
            <summary>
            	The source port number.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.DestinationPort">
            <summary>
            	The destination port number.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.SequenceNumber">
            <summary>
            	The sequence number of the first data octet in this segment (except
            	when SYN is present). If SYN is present the sequence number is the
            	initial sequence number (ISN) and the first data octet is ISN+1.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.AcknowledgmentNumber">
            <summary>
            	If the ACK control bit is set this field contains the value of the
            	next sequence number the sender of the segment is expecting to
            	receive. Once a connection is established this is always sent.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Offset">
            <summary>
            	This indicates where the data begins.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Flags">
            <summary>
            	Control bits.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Window">
            <summary>
            	The number of data octets beginning with the one indicated in the
            	acknowledgment field which the sender of this segment is willing to
            	accept.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Checksum">
            <summary>
            	The checksum field is the 16 bit one's complement of the one's
            	complement sum of all 16 bit words in the header and text. If a
            	segment contains an odd number of header and text octets to be
            	checksummed, the last octet is padded on the right with zeros to
            	form a 16 bit word for checksum purposes. The pad is not
            	transmitted as part of the segment.  While computing the checksum,
            	the checksum field itself is replaced with zeros.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.UrgentPointer">
            <summary>
            	This field communicates the current value of the urgent pointer as a
            	positive offset from the sequence number in this segment.  The
            	urgent pointer points to the sequence number of the octet following
            	the urgent data.  This field is only be interpreted in segments with
            	the URG control bit set.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Options">
            <summary>
            	Options may occupy space at the end of the TCP header and are a
            	multiple of 8 bits in length. All options are included in the
            	checksum. An option may begin on any octet boundary.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Padding">
            <summary>
            	The TCP header padding is used to ensure that the TCP header ends
            	and data begins on a 32 bit boundary. The padding is composed of
            	zeros.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Tcp.TcpPacket.Data">
            <summary>
            	The data.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Udp.UdpPacketArrivedHandler">
            <summary>
            	The handler for when a new packet has arrived.
            </summary>
        </member>
        <member name="T:Metro.TransportLayer.Udp.UdpPacket">
             <summary>
            		The User Datagram Protocol (UDP) is defined to make available a
            		datagram mode of packet-switched computer communication in the
            		environment of an interconnected set of computer networks. This
            		protocol assumes that the Internet Protocol (IP) is used as the
            		underlying protocol.
            
            		This protocol provides a procedure  for application programs to send
            		messages to other programs with a minimum of protocol mechanism. The
            		protocol is transaction oriented, and delivery and duplicate protection
            		are not guaranteed. Applications requiring ordered reliable delivery of
            		streams of data should use the Transmission Control Protocol (TCP).
             </summary>
        </member>
        <member name="F:Metro.TransportLayer.Udp.UdpPacket.m_sourcePort">
            <summary>
            	Source Port is an optional field, when meaningful, it indicates the port
            	of the sending process, and may be assumed to be the port to which a
            	reply should be addressed in the absence of any other information. If
            	not used, a value of zero is inserted.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Udp.UdpPacket.m_destPort">
            <summary>
            	Destination Port has a meaning within the context of a particular
            	internet destination address.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Udp.UdpPacket.m_length">
            <summary>
            	Length is the length in octets of this user datagram including this
            	header and the data. (This  means the minimum value of the length is
            	eight.)
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Udp.UdpPacket.m_checksum">
            <summary>
            	Checksum is the 16-bit one's complement of the one's complement sum of a
            	pseudo header of information from the IP header, the UDP header, and the
            	data, padded with zero octets at the end (if necessary) to make a
            	multiple of two octets.
            </summary>
        </member>
        <member name="F:Metro.TransportLayer.Udp.UdpPacket.m_data">
            <summary>
            	All data above the UDP header is placed in this buffer.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Udp.UdpPacket.#ctor">
            <summary>
            	Create a new Udp packet.
            </summary>
        </member>
        <member name="M:Metro.TransportLayer.Udp.UdpPacket.#ctor(System.Byte[])">
            <summary>
            	Create a new Udp packet.
            </summary>
            <param name="data">
            	The byte array representing the Udp packet.
            </param>
        </member>
        <member name="M:Metro.TransportLayer.Udp.UdpPacket.Serialize">
            <summary>
            	This method will calculate the length field and the checksum then pack the fields 
            	into a byte array in the format of a udp header. This can then be attached to a 
            	network layer protocol and then transmitted over the internet.
            </summary>
            <returns>
            	The return value is a byte array with the udp header at the beginning which can be
            	appended to a network layer protocol such as IP. 
            </returns>
            <remarks>
            	Note that NO CHECKSUM is calculated with this method.
            </remarks>
        </member>
        <member name="M:Metro.TransportLayer.Udp.UdpPacket.Serialize(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            	This method will calculate the length field and the checksum then pack the fields 
            	into a byte array in the format of a udp header. This can then be given data, 
            	attached to a network layer protocol and then transmitted over the internet.
            </summary>
            <param name="sourceAddress">
            	Destination address required for the checksum calculation.	
            </param>
            <param name="destAddress">
            	Destination address required for the checksum calculation.
            </param>
            <returns>
            	The return value is a byte array with the udp header at the beginning which can be
            	appended to a network layer protocol such as IP.
            </returns>
            <remarks>
            	Note that this method WILL CALCULATE A CHECKSUM.
            </remarks>
        </member>
        <member name="P:Metro.TransportLayer.Udp.UdpPacket.SourcePort">
            <summary>
            	Source Port is an optional field, when meaningful, it indicates the port
            	of the sending process, and may be assumed to be the port to which a
            	reply should be addressed in the absence of any other information. If
            	not used, a value of zero is inserted.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Udp.UdpPacket.DestinationPort">
            <summary>
            	Destination Port has a meaning within the context of a particular
            	internet destination address.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Udp.UdpPacket.Length">
            <summary>
            	Length is the length in octets of this user datagram including this
            	header and the data. (This  means the minimum value of the length is
            	eight.)
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            	The minimum length of the udp header is 8 bytes.
            </exception>
        </member>
        <member name="P:Metro.TransportLayer.Udp.UdpPacket.Checksum">
            <summary>
            	Checksum is the 16-bit one's complement of the one's complement sum of a
            	pseudo header of information from the IP header, the UDP header, and the
            	data, padded with zero octets at the end (if necessary) to make a
            	multiple of two octets.
            </summary>
        </member>
        <member name="P:Metro.TransportLayer.Udp.UdpPacket.Data">
            <summary>
            	All hte data above the UDP header is placed in this buffer.
            </summary>
        </member>
    </members>
</doc>
